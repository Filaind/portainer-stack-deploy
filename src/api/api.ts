/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * PortainerCE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API. Examples are available at https://documentation.portainer.io/api/api-examples/ You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).  # Authentication  Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used. Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request with the **Bearer** authentication mechanism.  Example:  ``` Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE ```  # Security  Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).  Different access policies are available:  - Public access - Authenticated access - Restricted access - Administrator access  ### Public access  No authentication is required to access the environments(endpoints) with this access policy.  ### Authenticated access  Authentication is required to access the environments(endpoints) with this access policy.  ### Restricted access  Authentication is required to access the environments(endpoints) with this access policy. Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.  ### Administrator access  Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.  # Execute Docker requests  Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).  Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.  To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).  # Private Registry  Using private registry, you will need to pass a based64 encoded JSON string ‘{\"registryId\":\\<registryID value\\>}’ inside the Request Header. The parameter name is \"X-Registry-Auth\". \\<registryID value\\> - The registry ID where the repository was created.  Example:  ``` eyJyZWdpc3RyeUlkIjoxfQ== ```  **NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/). 
 *
 * OpenAPI spec version: 2.19.1
 * Contact: info@portainer.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import * as https from "https";
import fetch from 'node-fetch';

https.globalAgent.options.rejectUnauthorized = false

const BASE_PATH = "http://localhost/api".replace(/\/+$/, "");
const portableFetch = fetch as any;
/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AuthAuthenticatePayload
 */
export interface AuthAuthenticatePayload {
    /**
     * Password
     * @type {string}
     * @memberof AuthAuthenticatePayload
     */
    password: string;
    /**
     * Username
     * @type {string}
     * @memberof AuthAuthenticatePayload
     */
    username: string;
}

/**
 * 
 * @export
 * @interface AuthAuthenticateResponse
 */
export interface AuthAuthenticateResponse {
    /**
     * JWT token used to authenticate against the API
     * @type {string}
     * @memberof AuthAuthenticateResponse
     */
    jwt?: string;
}

/**
 * 
 * @export
 * @interface AuthOauthPayload
 */
export interface AuthOauthPayload {
    /**
     * OAuth code returned from OAuth Provided
     * @type {string}
     * @memberof AuthOauthPayload
     */
    code?: string;
}

/**
 * 
 * @export
 * @interface BackupBackupPayload
 */
export interface BackupBackupPayload {
    /**
     * 
     * @type {string}
     * @memberof BackupBackupPayload
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface BackupRestorePayload
 */
export interface BackupRestorePayload {
    /**
     * 
     * @type {Array<number>}
     * @memberof BackupRestorePayload
     */
    fileContent?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof BackupRestorePayload
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof BackupRestorePayload
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface ContainersContainerGpusResponse
 */
export interface ContainersContainerGpusResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainersContainerGpusResponse
     */
    gpus?: string;
}

/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateFromFileContentPayload
 */
export interface CustomtemplatesCustomTemplateFromFileContentPayload {
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    description: string;
    /**
     * Content of stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    fileContent: string;
    /**
     * URL of the template's logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    logo?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    note?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - 'linux', 2 - 'windows' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    platform?: number;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    title: string;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    type: number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    variables?: Array<PortainerCustomTemplateVariableDefinition>;
}

/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateFromGitRepositoryPayload
 */
export interface CustomtemplatesCustomTemplateFromGitRepositoryPayload {
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    composeFilePathInRepository?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    description: string;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    isComposeFormat?: boolean;
    /**
     * URL of the template's logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    logo?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    note?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - 'linux', 2 - 'windows' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    platform?: number;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    repositoryPassword?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    repositoryReferenceName?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    repositoryURL: string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    repositoryUsername?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    title: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    tlsskipVerify?: boolean;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    type: number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    variables?: Array<PortainerCustomTemplateVariableDefinition>;
}

/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateUpdatePayload
 */
export interface CustomtemplatesCustomTemplateUpdatePayload {
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    composeFilePathInRepository?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    description: string;
    /**
     * Content of stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    fileContent: string;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    isComposeFormat?: boolean;
    /**
     * URL of the template's logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    logo?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    note?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - 'linux', 2 - 'windows' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    platform?: number;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryAuthentication?: boolean;
    /**
     * GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication is true and RepositoryUsername/RepositoryPassword are not provided
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryGitCredentialID?: number;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true and RepositoryGitCredentialID is 0
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryPassword?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryReferenceName?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryURL: string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true and RepositoryGitCredentialID is 0
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    repositoryUsername?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    title: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    tlsskipVerify?: boolean;
    /**
     * Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    type: number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    variables?: Array<PortainerCustomTemplateVariableDefinition>;
}

/**
 * 
 * @export
 * @interface CustomtemplatesFileResponse
 */
export interface CustomtemplatesFileResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomtemplatesFileResponse
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface DemoEnvironmentDetails
 */
export interface DemoEnvironmentDetails {
    /**
     * 
     * @type {boolean}
     * @memberof DemoEnvironmentDetails
     */
    enabled?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof DemoEnvironmentDetails
     */
    environments?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DemoEnvironmentDetails
     */
    users?: Array<number>;
}

/**
 * 
 * @export
 * @interface EdgeRegistryCredentials
 */
export interface EdgeRegistryCredentials {
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    secret?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    serverURL?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface EdgeStackPayload
 */
export interface EdgeStackPayload {
    /**
     * Content of stack folder
     * @type {Array<FilesystemDirEntry>}
     * @memberof EdgeStackPayload
     */
    dirEntries?: Array<FilesystemDirEntry>;
    /**
     * EdgeUpdateID is the ID of the edge update related to this stack. Used only for EE
     * @type {number}
     * @memberof EdgeStackPayload
     */
    edgeUpdateID?: number;
    /**
     * Name of the stack entry file
     * @type {string}
     * @memberof EdgeStackPayload
     */
    entryFileName?: string;
    /**
     * Used only for EE EnvVars is a list of environment variables to inject into the stack
     * @type {Array<PortainerPair>}
     * @memberof EdgeStackPayload
     */
    envVars?: Array<PortainerPair>;
    /**
     * Mount point for relative path
     * @type {string}
     * @memberof EdgeStackPayload
     */
    filesystemPath?: string;
    /**
     * ID of the stack
     * @type {number}
     * @memberof EdgeStackPayload
     */
    id?: number;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgeStackPayload
     */
    name?: string;
    /**
     * Namespace to use for kubernetes stack. Keep empty to use the manifest namespace.
     * @type {string}
     * @memberof EdgeStackPayload
     */
    namespace?: string;
    /**
     * PrePullImage is a flag indicating if the agent should pull the image before deploying the stack. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    prePullImage?: boolean;
    /**
     * RePullImage is a flag indicating if the agent should pull the image if it is already present on the node. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    rePullImage?: boolean;
    /**
     * RegistryCredentials holds the credentials for a Docker registry. Used only for EE
     * @type {Array<EdgeRegistryCredentials>}
     * @memberof EdgeStackPayload
     */
    registryCredentials?: Array<EdgeRegistryCredentials>;
    /**
     * RetryDeploy is a flag indicating if the agent should retry to deploy the stack if it fails. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    retryDeploy?: boolean;
    /**
     * RollbackTo specifies the stack file version to rollback to (only support to rollback to the last version currently)
     * @type {number}
     * @memberof EdgeStackPayload
     */
    rollbackTo?: number;
    /**
     * Content of the stack file (for compatibility to agent version less than 2.19.0)
     * @type {string}
     * @memberof EdgeStackPayload
     */
    stackFileContent?: string;
    /**
     * Is relative path supported
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    supportRelativePath?: boolean;
    /**
     * Version of the stack file
     * @type {number}
     * @memberof EdgeStackPayload
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface EdgegroupsDecoratedEdgeGroup
 */
export interface EdgegroupsDecoratedEdgeGroup {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    dynamic?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    endpoints?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    hasEdgeJob?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    hasEdgeStack?: boolean;
    /**
     * EdgeGroup Identifier
     * @type {number}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    partialMatch?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    tagIds?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    endpointTypes?: Array<number>;
}

/**
 * 
 * @export
 * @interface EdgegroupsEdgeGroupCreatePayload
 */
export interface EdgegroupsEdgeGroupCreatePayload {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    dynamic?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    endpoints?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    partialMatch?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    tagIDs?: Array<number>;
}

/**
 * 
 * @export
 * @interface EdgegroupsEdgeGroupUpdatePayload
 */
export interface EdgegroupsEdgeGroupUpdatePayload {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    dynamic?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    endpoints?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    partialMatch?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    tagIDs?: Array<number>;
}

/**
 * 
 * @export
 * @interface EdgejobsEdgeJobCreateFromFileContentPayload
 */
export interface EdgejobsEdgeJobCreateFromFileContentPayload {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    cronExpression?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    edgeGroups?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    endpoints?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    fileContent?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    recurring?: boolean;
}

/**
 * 
 * @export
 * @interface EdgejobsEdgeJobFileResponse
 */
export interface EdgejobsEdgeJobFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobFileResponse
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface EdgejobsEdgeJobUpdatePayload
 */
export interface EdgejobsEdgeJobUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    cronExpression?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    edgeGroups?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    endpoints?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    fileContent?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    recurring?: boolean;
}

/**
 * 
 * @export
 * @interface EdgejobsFileResponse
 */
export interface EdgejobsFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsFileResponse
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface EdgejobsTaskContainer
 */
export interface EdgejobsTaskContainer {
    /**
     * 
     * @type {number}
     * @memberof EdgejobsTaskContainer
     */
    endpointId?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsTaskContainer
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof EdgejobsTaskContainer
     */
    logsStatus?: number;
}

/**
 * 
 * @export
 * @interface EdgestacksEdgeStackFromGitRepositoryPayload
 */
export interface EdgestacksEdgeStackFromGitRepositoryPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - 'compose', 1 - 'kubernetes' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    deploymentType?: number;
    /**
     * List of identifiers of EdgeGroups
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    edgeGroups?: Array<number>;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    filePathInRepository?: string;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    name: string;
    /**
     * List of Registries to use for this stack
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    registries?: Array<number>;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    repositoryPassword?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    repositoryReferenceName?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    repositoryURL: string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    repositoryUsername?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    tlsskipVerify?: boolean;
    /**
     * Uses the manifest's namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    useManifestNamespaces?: boolean;
}

/**
 * 
 * @export
 * @interface EdgestacksEdgeStackFromStringPayload
 */
export interface EdgestacksEdgeStackFromStringPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - 'compose', 1 - 'kubernetes' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    deploymentType?: number;
    /**
     * List of identifiers of EdgeGroups
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    edgeGroups?: Array<number>;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    name: string;
    /**
     * List of Registries to use for this stack
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    registries?: Array<number>;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    stackFileContent: string;
    /**
     * Uses the manifest's namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    useManifestNamespaces?: boolean;
}

/**
 * 
 * @export
 * @interface EdgestacksStackFileResponse
 */
export interface EdgestacksStackFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgestacksStackFileResponse
     */
    stackFileContent?: string;
}

/**
 * 
 * @export
 * @interface EdgestacksUpdateEdgeStackPayload
 */
export interface EdgestacksUpdateEdgeStackPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - 'compose', 1 - 'kubernetes' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    deploymentType?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    edgeGroups?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    stackFileContent?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    updateVersion?: boolean;
    /**
     * Uses the manifest's namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    useManifestNamespaces?: boolean;
}

/**
 * 
 * @export
 * @interface EdgestacksUpdateStatusPayload
 */
export interface EdgestacksUpdateStatusPayload {
    /**
     * 
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    endpointID?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgestacksUpdateStatusPayload
     */
    error?: string;
    /**
     * Deprecated
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    status?: number;
    /**
     * 
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface EndpointedgeEdgeJobResponse
 */
export interface EndpointedgeEdgeJobResponse {
    /**
     * Whether to collect logs
     * @type {boolean}
     * @memberof EndpointedgeEdgeJobResponse
     */
    collectLogs?: boolean;
    /**
     * A cron expression to schedule this job
     * @type {string}
     * @memberof EndpointedgeEdgeJobResponse
     */
    cronExpression?: string;
    /**
     * EdgeJob Identifier
     * @type {number}
     * @memberof EndpointedgeEdgeJobResponse
     */
    id?: number;
    /**
     * Script to run
     * @type {string}
     * @memberof EndpointedgeEdgeJobResponse
     */
    script?: string;
    /**
     * Version of this EdgeJob
     * @type {number}
     * @memberof EndpointedgeEdgeJobResponse
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface EndpointedgeEndpointEdgeStatusInspectResponse
 */
export interface EndpointedgeEndpointEdgeStatusInspectResponse {
    /**
     * The current value of CheckinInterval
     * @type {number}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    checkin?: number;
    /**
     * 
     * @type {string}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    credentials?: string;
    /**
     * The tunnel port
     * @type {number}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    port?: number;
    /**
     * List of requests for jobs to run on the environment(endpoint)
     * @type {Array<EndpointedgeEdgeJobResponse>}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    schedules?: Array<EndpointedgeEdgeJobResponse>;
    /**
     * List of stacks to be deployed on the environments(endpoints)
     * @type {Array<EndpointedgeStackStatusResponse>}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    stacks?: Array<EndpointedgeStackStatusResponse>;
    /**
     * Status represents the environment(endpoint) status
     * @type {string}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface EndpointedgeStackStatusResponse
 */
export interface EndpointedgeStackStatusResponse {
    /**
     * EdgeStack Identifier
     * @type {number}
     * @memberof EndpointedgeStackStatusResponse
     */
    id?: number;
    /**
     * Version of this stack
     * @type {number}
     * @memberof EndpointedgeStackStatusResponse
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface EndpointgroupsEndpointGroupCreatePayload
 */
export interface EndpointgroupsEndpointGroupCreatePayload {
    /**
     * List of environment(endpoint) identifiers that will be part of this group
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    associatedEndpoints?: Array<number>;
    /**
     * Environment(Endpoint) group description
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    description?: string;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    name: string;
    /**
     * List of tag identifiers to which this environment(endpoint) group is associated
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    tagIDs?: Array<number>;
}

/**
 * 
 * @export
 * @interface EndpointgroupsEndpointGroupUpdatePayload
 */
export interface EndpointgroupsEndpointGroupUpdatePayload {
    /**
     * Environment(Endpoint) group description
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    description?: string;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    name?: string;
    /**
     * List of tag identifiers associated to the environment(endpoint) group
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    tagIDs?: Array<number>;
    /**
     * 
     * @type {PortainerTeamAccessPolicies}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * 
     * @type {PortainerUserAccessPolicies}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
}

/**
 * 
 * @export
 * @interface EndpointsDockerhubStatusResponse
 */
export interface EndpointsDockerhubStatusResponse {
    /**
     * Daily limit
     * @type {number}
     * @memberof EndpointsDockerhubStatusResponse
     */
    limit?: number;
    /**
     * Remaiming images to pull
     * @type {number}
     * @memberof EndpointsDockerhubStatusResponse
     */
    remaining?: number;
}

/**
 * 
 * @export
 * @interface EndpointsEndpointCreateGlobalKeyResponse
 */
export interface EndpointsEndpointCreateGlobalKeyResponse {
    /**
     * Environment(Endpoint) Identifier
     * @type {number}
     * @memberof EndpointsEndpointCreateGlobalKeyResponse
     */
    endpointID?: number;
}

/**
 * 
 * @export
 * @interface EndpointsEndpointSettingsUpdatePayload
 */
export interface EndpointsEndpointSettingsUpdatePayload {
    /**
     * Whether non-administrator should be able to use bind mounts when creating containers
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowBindMountsForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use container capabilities
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowContainerCapabilitiesForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use device mapping
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowDeviceMappingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use the host pid
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowHostNamespaceForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use privileged mode when creating containers
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowPrivilegedModeForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to manage stacks
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowStackManagementForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use sysctl settings
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowSysctlSettingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to browse volumes
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    allowVolumeBrowserForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    enableGPUManagement?: boolean;
    /**
     * Whether host management features are enabled
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    enableHostManagementFeatures?: boolean;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    gpus?: Array<PortainerPair>;
}

/**
 * 
 * @export
 * @interface EndpointsEndpointUpdatePayload
 */
export interface EndpointsEndpointUpdatePayload {
    /**
     * Azure application ID
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    azureApplicationID?: string;
    /**
     * Azure authentication key
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    azureAuthenticationKey?: string;
    /**
     * Azure tenant ID
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    azureTenantID?: string;
    /**
     * The check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    edgeCheckinInterval?: number;
    /**
     * GPUs information
     * @type {Array<PortainerPair>}
     * @memberof EndpointsEndpointUpdatePayload
     */
    gpus?: Array<PortainerPair>;
    /**
     * Group identifier
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    groupID?: number;
    /**
     * Associated Kubernetes data
     * @type {PortainerKubernetesData}
     * @memberof EndpointsEndpointUpdatePayload
     */
    kubernetes?: PortainerKubernetesData;
    /**
     * Name that will be used to identify this environment(endpoint)
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    name?: string;
    /**
     * URL or IP address where exposed containers will be reachable.\\ Defaults to URL if not specified
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    publicURL?: string;
    /**
     * The status of the environment(endpoint) (1 - up, 2 - down)
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    status?: number;
    /**
     * List of tag identifiers to which this environment(endpoint) is associated
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdatePayload
     */
    tagIDs?: Array<number>;
    /**
     * 
     * @type {PortainerTeamAccessPolicies}
     * @memberof EndpointsEndpointUpdatePayload
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * Require TLS to connect against this environment(endpoint)
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    tls?: boolean;
    /**
     * Skip client verification when using TLS
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    tlsskipClientVerify?: boolean;
    /**
     * Skip server verification when using TLS
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    tlsskipVerify?: boolean;
    /**
     * URL or IP address of a Docker host
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    url?: string;
    /**
     * 
     * @type {PortainerUserAccessPolicies}
     * @memberof EndpointsEndpointUpdatePayload
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
}

/**
 * 
 * @export
 * @interface EndpointsEndpointUpdateRelationsPayload
 */
export interface EndpointsEndpointUpdateRelationsPayload {
    /**
     * 
     * @type {{ [key: string]: EndpointsEndpointUpdateRelationsPayloadRelations; }}
     * @memberof EndpointsEndpointUpdateRelationsPayload
     */
    relations?: { [key: string]: EndpointsEndpointUpdateRelationsPayloadRelations; };
}

/**
 * 
 * @export
 * @interface EndpointsEndpointUpdateRelationsPayloadRelations
 */
export interface EndpointsEndpointUpdateRelationsPayloadRelations {
    /**
     * 
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    edgeGroups?: Array<number>;
    /**
     * Environment(Endpoint) group identifier
     * @type {number}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    group?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    tags?: Array<number>;
}

/**
 * 
 * @export
 * @interface EndpointsRegistryAccessPayload
 */
export interface EndpointsRegistryAccessPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof EndpointsRegistryAccessPayload
     */
    namespaces?: Array<string>;
    /**
     * 
     * @type {PortainerTeamAccessPolicies}
     * @memberof EndpointsRegistryAccessPayload
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * 
     * @type {PortainerUserAccessPolicies}
     * @memberof EndpointsRegistryAccessPayload
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
}

/**
 * 
 * @export
 * @interface FdoDeviceConfigurePayload
 */
export interface FdoDeviceConfigurePayload {
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    edgeID?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    edgeKey?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FdoDeviceConfigurePayload
     */
    profile?: number;
}

/**
 * 
 * @export
 * @interface FdoFdoConfigurePayload
 */
export interface FdoFdoConfigurePayload {
    /**
     * 
     * @type {boolean}
     * @memberof FdoFdoConfigurePayload
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    ownerPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    ownerURL?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    ownerUsername?: string;
}

/**
 * 
 * @export
 * @interface FilesystemDirEntry
 */
export interface FilesystemDirEntry {
    /**
     * 
     * @type {string}
     * @memberof FilesystemDirEntry
     */
    content?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FilesystemDirEntry
     */
    isFile?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FilesystemDirEntry
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FilesystemDirEntry
     */
    permissions?: number;
}

/**
 * 
 * @export
 * @interface GitopsFileResponse
 */
export interface GitopsFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GitopsFileResponse
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface GitopsRepositoryFilePreviewPayload
 */
export interface GitopsRepositoryFilePreviewPayload {
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    repository: string;
    /**
     * Path to file whose content will be read
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    targetFile?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    tlsskipVerify?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface GittypesGitAuthentication
 */
export interface GittypesGitAuthentication {
    /**
     * Git credentials identifier when the value is not 0 When the value is 0, Username and Password are set without using saved credential This is introduced since 2.15.0
     * @type {number}
     * @memberof GittypesGitAuthentication
     */
    gitCredentialID?: number;
    /**
     * 
     * @type {string}
     * @memberof GittypesGitAuthentication
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof GittypesGitAuthentication
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface GittypesRepoConfig
 */
export interface GittypesRepoConfig {
    /**
     * Git credentials
     * @type {GittypesGitAuthentication}
     * @memberof GittypesRepoConfig
     */
    authentication?: GittypesGitAuthentication;
    /**
     * Path to where the config file is in this url/refName
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    configFilePath?: string;
    /**
     * Repository hash
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    configHash?: string;
    /**
     * The reference name
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    referenceName?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof GittypesRepoConfig
     */
    tlsskipVerify?: boolean;
    /**
     * The repo url
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface HelmAddHelmRepoUrlPayload
 */
export interface HelmAddHelmRepoUrlPayload {
    /**
     * 
     * @type {string}
     * @memberof HelmAddHelmRepoUrlPayload
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface HelmHelmUserRepositoryResponse
 */
export interface HelmHelmUserRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmHelmUserRepositoryResponse
     */
    globalRepository?: string;
    /**
     * 
     * @type {Array<PortainerHelmUserRepository>}
     * @memberof HelmHelmUserRepositoryResponse
     */
    userRepositories?: Array<PortainerHelmUserRepository>;
}

/**
 * 
 * @export
 * @interface HelmInstallChartPayload
 */
export interface HelmInstallChartPayload {
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    chart?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    repo?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    values?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sApplication
 */
export interface KubernetesK8sApplication {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sApplication
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    uid?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sIngressController
 */
export interface KubernetesK8sIngressController {
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    availability?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    className?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    _new?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    used?: boolean;
}

/**
 * 
 * @export
 * @interface KubernetesK8sIngressDeleteRequests
 */
export interface KubernetesK8sIngressDeleteRequests {
    [key: string]: Array<string>;

}

/**
 * 
 * @export
 * @interface KubernetesK8sIngressInfo
 */
export interface KubernetesK8sIngressInfo {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sIngressInfo
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    className?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    creationDate?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sIngressInfo
     */
    hosts?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sIngressInfo
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    namespace?: string;
    /**
     * 
     * @type {Array<KubernetesK8sIngressPath>}
     * @memberof KubernetesK8sIngressInfo
     */
    paths?: Array<KubernetesK8sIngressPath>;
    /**
     * 
     * @type {Array<KubernetesK8sIngressTLS>}
     * @memberof KubernetesK8sIngressInfo
     */
    TLS?: Array<KubernetesK8sIngressTLS>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    UID?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sIngressPath
 */
export interface KubernetesK8sIngressPath {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    ingressName?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    pathType?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sIngressPath
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    serviceName?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sIngressTLS
 */
export interface KubernetesK8sIngressTLS {
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sIngressTLS
     */
    hosts?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressTLS
     */
    secretName?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sNamespaceDetails
 */
export interface KubernetesK8sNamespaceDetails {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sNamespaceDetails
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sNamespaceDetails
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sServiceDeleteRequests
 */
export interface KubernetesK8sServiceDeleteRequests {
    [key: string]: Array<string>;

}

/**
 * 
 * @export
 * @interface KubernetesK8sServiceInfo
 */
export interface KubernetesK8sServiceInfo {
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sServiceInfo
     */
    allocateLoadBalancerNodePorts?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    annotations?: { [key: string]: string; };
    /**
     * serviceList screen
     * @type {Array<KubernetesK8sApplication>}
     * @memberof KubernetesK8sServiceInfo
     */
    applications?: Array<KubernetesK8sApplication>;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sServiceInfo
     */
    clusterIPs?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    creationTimestamp?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sServiceInfo
     */
    externalIPs?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    externalName?: string;
    /**
     * 
     * @type {Array<KubernetesK8sServiceIngress>}
     * @memberof KubernetesK8sServiceInfo
     */
    ingressStatus?: Array<KubernetesK8sServiceIngress>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    namespace?: string;
    /**
     * 
     * @type {Array<KubernetesK8sServicePort>}
     * @memberof KubernetesK8sServiceInfo
     */
    ports?: Array<KubernetesK8sServicePort>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    selector?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    uid?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sServiceIngress
 */
export interface KubernetesK8sServiceIngress {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceIngress
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceIngress
     */
    IP?: string;
}

/**
 * 
 * @export
 * @interface KubernetesK8sServicePort
 */
export interface KubernetesK8sServicePort {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sServicePort
     */
    nodePort?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sServicePort
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    targetPort?: string;
}

/**
 * 
 * @export
 * @interface KubernetesNamespacesToggleSystemPayload
 */
export interface KubernetesNamespacesToggleSystemPayload {
    /**
     * Toggle the system state of this namespace to true or false
     * @type {boolean}
     * @memberof KubernetesNamespacesToggleSystemPayload
     */
    system?: boolean;
}

/**
 * 
 * @export
 * @interface LdapCheckPayload
 */
export interface LdapCheckPayload {
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof LdapCheckPayload
     */
    ldapsettings?: PortainerLDAPSettings;
}

/**
 * 
 * @export
 * @interface MotdMotdResponse
 */
export interface MotdMotdResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MotdMotdResponse
     */
    contentLayout?: { [key: string]: string; };
    /**
     * 
     * @type {Array<number>}
     * @memberof MotdMotdResponse
     */
    hash?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    style?: string;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface OpenamtDeviceActionPayload
 */
export interface OpenamtDeviceActionPayload {
    /**
     * 
     * @type {string}
     * @memberof OpenamtDeviceActionPayload
     */
    action?: string;
}

/**
 * 
 * @export
 * @interface OpenamtDeviceFeaturesPayload
 */
export interface OpenamtDeviceFeaturesPayload {
    /**
     * 
     * @type {PortainerOpenAMTDeviceEnabledFeatures}
     * @memberof OpenamtDeviceFeaturesPayload
     */
    features?: PortainerOpenAMTDeviceEnabledFeatures;
}

/**
 * 
 * @export
 * @interface OpenamtOpenAMTConfigurePayload
 */
export interface OpenamtOpenAMTConfigurePayload {
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    certFileContent?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    certFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    certFilePassword?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    domainName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    mpspassword?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    mpsserver?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    mpsuser?: string;
}

/**
 * 
 * @export
 * @interface PortainerAPIKey
 */
export interface PortainerAPIKey {
    /**
     * Unix timestamp (UTC) when the API key was created
     * @type {number}
     * @memberof PortainerAPIKey
     */
    dateCreated?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerAPIKey
     */
    description?: string;
    /**
     * Digest represents SHA256 hash of the raw API key
     * @type {Array<number>}
     * @memberof PortainerAPIKey
     */
    digest?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof PortainerAPIKey
     */
    id?: number;
    /**
     * Unix timestamp (UTC) when the API key was last used
     * @type {number}
     * @memberof PortainerAPIKey
     */
    lastUsed?: number;
    /**
     * API key identifier (7 char prefix)
     * @type {string}
     * @memberof PortainerAPIKey
     */
    prefix?: string;
    /**
     * User Identifier
     * @type {number}
     * @memberof PortainerAPIKey
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface PortainerAccessPolicy
 */
export interface PortainerAccessPolicy {
    /**
     * Role identifier. Reference the role that will be associated to this access policy
     * @type {number}
     * @memberof PortainerAccessPolicy
     */
    roleId?: number;
}

/**
 * 
 * @export
 * @interface PortainerAuthorizations
 */
export interface PortainerAuthorizations {
    [key: string]: boolean;

}

/**
 * 
 * @export
 * @interface PortainerAutoUpdateSettings
 */
export interface PortainerAutoUpdateSettings {
    /**
     * Pull latest image
     * @type {boolean}
     * @memberof PortainerAutoUpdateSettings
     */
    forcePullImage?: boolean;
    /**
     * Force update ignores repo changes
     * @type {boolean}
     * @memberof PortainerAutoUpdateSettings
     */
    forceUpdate?: boolean;
    /**
     * Auto update interval
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    interval?: string;
    /**
     * Autoupdate job id
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    jobID?: string;
    /**
     * A UUID generated from client
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    webhook?: string;
}

/**
 * 
 * @export
 * @interface PortainerAzureCredentials
 */
export interface PortainerAzureCredentials {
    /**
     * Azure application ID
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    applicationID?: string;
    /**
     * Azure authentication key
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    authenticationKey?: string;
    /**
     * Azure tenant ID
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    tenantID?: string;
}

/**
 * 
 * @export
 * @interface PortainerCustomTemplate
 */
export interface PortainerCustomTemplate {
    /**
     * User identifier who created this template
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    createdByUserId?: number;
    /**
     * Description of the template
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    description?: string;
    /**
     * Path to the Stack file
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    entryPoint?: string;
    /**
     * 
     * @type {GittypesRepoConfig}
     * @memberof PortainerCustomTemplate
     */
    gitConfig?: GittypesRepoConfig;
    /**
     * CustomTemplate Identifier
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    id?: number;
    /**
     * URL of the template's logo
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    logo?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    note?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - 'linux', 2 - 'windows'
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    platform?: number;
    /**
     * Path on disk to the repository hosting the Stack file
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    projectPath?: string;
    /**
     * 
     * @type {PortainerResourceControl}
     * @memberof PortainerCustomTemplate
     */
    resourceControl?: PortainerResourceControl;
    /**
     * Title of the template
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    title?: string;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    type?: number;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof PortainerCustomTemplate
     */
    isComposeFormat?: boolean;
    /**
     * 
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof PortainerCustomTemplate
     */
    variables?: Array<PortainerCustomTemplateVariableDefinition>;
}

/**
 * 
 * @export
 * @interface PortainerCustomTemplateVariableDefinition
 */
export interface PortainerCustomTemplateVariableDefinition {
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface PortainerDockerSnapshot
 */
export interface PortainerDockerSnapshot {
    /**
     * 
     * @type {PortainerDockerSnapshotRaw}
     * @memberof PortainerDockerSnapshot
     */
    dockerSnapshotRaw?: PortainerDockerSnapshotRaw;
    /**
     * 
     * @type {string}
     * @memberof PortainerDockerSnapshot
     */
    dockerVersion?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerDockerSnapshot
     */
    gpuUseAll?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerDockerSnapshot
     */
    gpuUseList?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    healthyContainerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    imageCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    nodeCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    runningContainerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    serviceCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    stackCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    stoppedContainerCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerDockerSnapshot
     */
    swarm?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    totalCPU?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    totalMemory?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    unhealthyContainerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    volumeCount?: number;
}

/**
 * 
 * @export
 * @interface PortainerDockerSnapshotRaw
 */
export interface PortainerDockerSnapshotRaw {
}

/**
 * 
 * @export
 * @interface PortainerEcrData
 */
export interface PortainerEcrData {
    /**
     * 
     * @type {string}
     * @memberof PortainerEcrData
     */
    region?: string;
}

/**
 * 
 * @export
 * @interface PortainerEdgeGroup
 */
export interface PortainerEdgeGroup {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeGroup
     */
    dynamic?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeGroup
     */
    endpoints?: Array<number>;
    /**
     * EdgeGroup Identifier
     * @type {number}
     * @memberof PortainerEdgeGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeGroup
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeGroup
     */
    partialMatch?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeGroup
     */
    tagIds?: Array<number>;
}

/**
 * 
 * @export
 * @interface PortainerEdgeJob
 */
export interface PortainerEdgeJob {
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    cronExpression?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeJob
     */
    edgeGroups?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: PortainerEdgeJobEndpointMeta; }}
     * @memberof PortainerEdgeJob
     */
    endpoints?: { [key: string]: PortainerEdgeJobEndpointMeta; };
    /**
     * EdgeJob Identifier
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeJob
     */
    recurring?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    scriptPath?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    version?: number;
    /**
     * Field used for log collection of Endpoints belonging to EdgeGroups
     * @type {{ [key: string]: PortainerEdgeJobEndpointMeta; }}
     * @memberof PortainerEdgeJob
     */
    groupLogsCollection?: { [key: string]: PortainerEdgeJobEndpointMeta; };
}

/**
 * 
 * @export
 * @interface PortainerEdgeJobEndpointMeta
 */
export interface PortainerEdgeJobEndpointMeta {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeJobEndpointMeta
     */
    collectLogs?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJobEndpointMeta
     */
    logsStatus?: number;
}

/**
 * 
 * @export
 * @interface PortainerEdgeStack
 */
export interface PortainerEdgeStack {
    /**
     * StatusArray    map[EndpointID][]EdgeStackStatus `json:\"StatusArray\"`
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    creationDate?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeStack
     */
    edgeGroups?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    entryPoint?: string;
    /**
     * EdgeStack Identifier
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    numDeployments?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    projectPath?: string;
    /**
     * Deprecated
     * @type {boolean}
     * @memberof PortainerEdgeStack
     */
    prune?: boolean;
    /**
     * 
     * @type {{ [key: string]: PortainerEdgeStackStatus; }}
     * @memberof PortainerEdgeStack
     */
    status?: { [key: string]: PortainerEdgeStackStatus; };
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    version?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    deploymentType?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    manifestPath?: string;
    /**
     * Uses the manifest's namespaces instead of the default one
     * @type {boolean}
     * @memberof PortainerEdgeStack
     */
    useManifestNamespaces?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerEdgeStackDeploymentStatus
 */
export interface PortainerEdgeStackDeploymentStatus {
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    error?: string;
    /**
     * EE only feature
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    rollbackTo?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    type?: number;
}

/**
 * 
 * @export
 * @interface PortainerEdgeStackStatus
 */
export interface PortainerEdgeStackStatus {
    /**
     * Deprecated
     * @type {number}
     * @memberof PortainerEdgeStackStatus
     */
    type?: number;
    /**
     * EE only feature
     * @type {PortainerStackDeploymentInfo}
     * @memberof PortainerEdgeStackStatus
     */
    deploymentInfo?: PortainerStackDeploymentInfo;
    /**
     * Deprecated
     * @type {PortainerEdgeStackStatusDetails}
     * @memberof PortainerEdgeStackStatus
     */
    details?: PortainerEdgeStackStatusDetails;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackStatus
     */
    endpointID?: number;
    /**
     * Deprecated
     * @type {string}
     * @memberof PortainerEdgeStackStatus
     */
    error?: string;
    /**
     * 
     * @type {Array<PortainerEdgeStackDeploymentStatus>}
     * @memberof PortainerEdgeStackStatus
     */
    status?: Array<PortainerEdgeStackDeploymentStatus>;
}

/**
 * 
 * @export
 * @interface PortainerEdgeStackStatusDetails
 */
export interface PortainerEdgeStackStatusDetails {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    acknowledged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    error?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    imagesPulled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    ok?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    pending?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    remoteUpdateSuccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    remove?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerEndpoint
 */
export interface PortainerEndpoint {
    /**
     * The identifier of the AMT Device associated with this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    aMTDeviceGUID?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    authorizedTeams?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    authorizedUsers?: Array<number>;
    /**
     * 
     * @type {PortainerAzureCredentials}
     * @memberof PortainerEndpoint
     */
    azureCredentials?: PortainerAzureCredentials;
    /**
     * Maximum version of docker-compose
     * @type {string}
     * @memberof PortainerEndpoint
     */
    composeSyntaxMaxVersion?: string;
    /**
     * The check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof PortainerEndpoint
     */
    edgeCheckinInterval?: number;
    /**
     * The identifier of the edge agent associated with this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    edgeID?: string;
    /**
     * The key which is used to map the agent to Portainer
     * @type {string}
     * @memberof PortainerEndpoint
     */
    edgeKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    enableGPUManagement?: boolean;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof PortainerEndpoint
     */
    gpus?: Array<PortainerPair>;
    /**
     * Environment(Endpoint) group identifier
     * @type {number}
     * @memberof PortainerEndpoint
     */
    groupId?: number;
    /**
     * Heartbeat indicates the heartbeat status of an edge environment
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    heartbeat?: boolean;
    /**
     * Environment(Endpoint) Identifier
     * @type {number}
     * @memberof PortainerEndpoint
     */
    id?: number;
    /**
     * Associated Kubernetes data
     * @type {PortainerKubernetesData}
     * @memberof PortainerEndpoint
     */
    kubernetes?: PortainerKubernetesData;
    /**
     * Environment(Endpoint) name
     * @type {string}
     * @memberof PortainerEndpoint
     */
    name?: string;
    /**
     * Whether we need to run any \"post init migrations\".
     * @type {PortainerEndpointPostInitMigrations}
     * @memberof PortainerEndpoint
     */
    postInitMigrations?: PortainerEndpointPostInitMigrations;
    /**
     * URL or IP address where exposed containers will be reachable
     * @type {string}
     * @memberof PortainerEndpoint
     */
    publicURL?: string;
    /**
     * List of snapshots
     * @type {Array<PortainerDockerSnapshot>}
     * @memberof PortainerEndpoint
     */
    snapshots?: Array<PortainerDockerSnapshot>;
    /**
     * The status of the environment(endpoint) (1 - up, 2 - down)
     * @type {number}
     * @memberof PortainerEndpoint
     */
    status?: number;
    /**
     * Deprecated fields Deprecated in DBVersion == 4
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    TLS?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    tLSCACert?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    tLSCert?: string;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerEndpoint
     */
    tLSConfig?: PortainerTLSConfiguration;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    tLSKey?: string;
    /**
     * List of tag identifiers to which this environment(endpoint) is associated
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    tagIds?: Array<number>;
    /**
     * Deprecated in DBVersion == 22
     * @type {Array<string>}
     * @memberof PortainerEndpoint
     */
    tags?: Array<string>;
    /**
     * List of team identifiers authorized to connect to this environment(endpoint)
     * @type {PortainerTeamAccessPolicies}
     * @memberof PortainerEndpoint
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint).
     * @type {number}
     * @memberof PortainerEndpoint
     */
    type?: number;
    /**
     * URL or IP address of the Docker host associated to this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    URL?: string;
    /**
     * List of user identifiers authorized to connect to this environment(endpoint)
     * @type {PortainerUserAccessPolicies}
     * @memberof PortainerEndpoint
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
    /**
     * 
     * @type {PortainerEndpointAgent}
     * @memberof PortainerEndpoint
     */
    agent?: PortainerEndpointAgent;
    /**
     * 
     * @type {PortainerEnvironmentEdgeSettings}
     * @memberof PortainerEndpoint
     */
    edge?: PortainerEnvironmentEdgeSettings;
    /**
     * Deprecated v2.18
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    isEdgeDevice?: boolean;
    /**
     * LastCheckInDate mark last check-in date on checkin
     * @type {number}
     * @memberof PortainerEndpoint
     */
    lastCheckInDate?: number;
    /**
     * QueryDate of each query with the endpoints list
     * @type {number}
     * @memberof PortainerEndpoint
     */
    queryDate?: number;
    /**
     * Environment(Endpoint) specific security settings
     * @type {PortainerEndpointSecuritySettings}
     * @memberof PortainerEndpoint
     */
    securitySettings?: PortainerEndpointSecuritySettings;
    /**
     * Whether the device has been trusted or not by the user
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    userTrusted?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerEndpointAgent
 */
export interface PortainerEndpointAgent {
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpointAgent
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface PortainerEndpointAuthorizations
 */
export interface PortainerEndpointAuthorizations {
    [key: string]: PortainerAuthorizations;

}

/**
 * 
 * @export
 * @interface PortainerEndpointGroup
 */
export interface PortainerEndpointGroup {
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    authorizedTeams?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    authorizedUsers?: Array<number>;
    /**
     * Description associated to the environment(endpoint) group
     * @type {string}
     * @memberof PortainerEndpointGroup
     */
    description?: string;
    /**
     * Environment(Endpoint) group Identifier
     * @type {number}
     * @memberof PortainerEndpointGroup
     */
    id?: number;
    /**
     * Deprecated fields
     * @type {Array<PortainerPair>}
     * @memberof PortainerEndpointGroup
     */
    labels?: Array<PortainerPair>;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof PortainerEndpointGroup
     */
    name?: string;
    /**
     * List of tags associated to this environment(endpoint) group
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    tagIds?: Array<number>;
    /**
     * Deprecated in DBVersion == 22
     * @type {Array<string>}
     * @memberof PortainerEndpointGroup
     */
    tags?: Array<string>;
    /**
     * 
     * @type {PortainerTeamAccessPolicies}
     * @memberof PortainerEndpointGroup
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * 
     * @type {PortainerUserAccessPolicies}
     * @memberof PortainerEndpointGroup
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
}

/**
 * 
 * @export
 * @interface PortainerEndpointPostInitMigrations
 */
export interface PortainerEndpointPostInitMigrations {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpointPostInitMigrations
     */
    migrateGPUs?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpointPostInitMigrations
     */
    migrateIngresses?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerEndpointSecuritySettings
 */
export interface PortainerEndpointSecuritySettings {
    /**
     * Whether non-administrator should be able to use bind mounts when creating containers
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowBindMountsForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use container capabilities
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowContainerCapabilitiesForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use device mapping
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowDeviceMappingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use the host pid
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowHostNamespaceForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use privileged mode when creating containers
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowPrivilegedModeForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to manage stacks
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowStackManagementForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use sysctl settings
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowSysctlSettingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to browse volumes
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    allowVolumeBrowserForRegularUsers?: boolean;
    /**
     * Whether host management features are enabled
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    enableHostManagementFeatures?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerEnvironmentEdgeSettings
 */
export interface PortainerEnvironmentEdgeSettings {
    /**
     * The command list interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    commandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    pingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    snapshotInterval?: number;
    /**
     * Whether the device has been started in edge async mode
     * @type {boolean}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    asyncMode?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerFDOConfiguration
 */
export interface PortainerFDOConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerFDOConfiguration
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    ownerPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    ownerURL?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    ownerUsername?: string;
}

/**
 * 
 * @export
 * @interface PortainerGitlabRegistryData
 */
export interface PortainerGitlabRegistryData {
    /**
     * 
     * @type {string}
     * @memberof PortainerGitlabRegistryData
     */
    instanceURL?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerGitlabRegistryData
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerGitlabRegistryData
     */
    projectPath?: string;
}

/**
 * 
 * @export
 * @interface PortainerHelmUserRepository
 */
export interface PortainerHelmUserRepository {
    /**
     * Membership Identifier
     * @type {number}
     * @memberof PortainerHelmUserRepository
     */
    id?: number;
    /**
     * Helm repository URL
     * @type {string}
     * @memberof PortainerHelmUserRepository
     */
    URL?: string;
    /**
     * User identifier
     * @type {number}
     * @memberof PortainerHelmUserRepository
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface PortainerInternalAuthSettings
 */
export interface PortainerInternalAuthSettings {
    /**
     * 
     * @type {number}
     * @memberof PortainerInternalAuthSettings
     */
    requiredPasswordLength?: number;
}

/**
 * 
 * @export
 * @interface PortainerK8sNamespaceInfo
 */
export interface PortainerK8sNamespaceInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerK8sNamespaceInfo
     */
    isDefault?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerK8sNamespaceInfo
     */
    isSystem?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerK8sNodeLimits
 */
export interface PortainerK8sNodeLimits {
    /**
     * 
     * @type {number}
     * @memberof PortainerK8sNodeLimits
     */
    CPU?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerK8sNodeLimits
     */
    memory?: number;
}

/**
 * 
 * @export
 * @interface PortainerK8sNodesLimits
 */
export interface PortainerK8sNodesLimits {
    [key: string]: PortainerK8sNodeLimits;

}

/**
 * 
 * @export
 * @interface PortainerKubernetesConfiguration
 */
export interface PortainerKubernetesConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    allowNoneIngressClass?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    enableResourceOverCommit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    ingressAvailabilityPerNamespace?: boolean;
    /**
     * 
     * @type {Array<PortainerKubernetesIngressClassConfig>}
     * @memberof PortainerKubernetesConfiguration
     */
    ingressClasses?: Array<PortainerKubernetesIngressClassConfig>;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesConfiguration
     */
    resourceOverCommitPercentage?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    restrictDefaultNamespace?: boolean;
    /**
     * 
     * @type {Array<PortainerKubernetesStorageClassConfig>}
     * @memberof PortainerKubernetesConfiguration
     */
    storageClasses?: Array<PortainerKubernetesStorageClassConfig>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    useLoadBalancer?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    useServerMetrics?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerKubernetesData
 */
export interface PortainerKubernetesData {
    /**
     * 
     * @type {PortainerKubernetesConfiguration}
     * @memberof PortainerKubernetesData
     */
    configuration?: PortainerKubernetesConfiguration;
    /**
     * 
     * @type {PortainerKubernetesFlags}
     * @memberof PortainerKubernetesData
     */
    flags?: PortainerKubernetesFlags;
    /**
     * 
     * @type {Array<PortainerKubernetesSnapshot>}
     * @memberof PortainerKubernetesData
     */
    snapshots?: Array<PortainerKubernetesSnapshot>;
}

/**
 * 
 * @export
 * @interface PortainerKubernetesFlags
 */
export interface PortainerKubernetesFlags {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    isServerIngressClassDetected?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    isServerMetricsDetected?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    isServerStorageDetected?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerKubernetesIngressClassConfig
 */
export interface PortainerKubernetesIngressClassConfig {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    blocked?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    blockedNamespaces?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface PortainerKubernetesSnapshot
 */
export interface PortainerKubernetesSnapshot {
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesSnapshot
     */
    kubernetesVersion?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    nodeCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    totalCPU?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    totalMemory?: number;
}

/**
 * 
 * @export
 * @interface PortainerKubernetesStorageClassConfig
 */
export interface PortainerKubernetesStorageClassConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    accessModes?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    allowVolumeExpansion?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    provisioner?: string;
}

/**
 * 
 * @export
 * @interface PortainerLDAPGroupSearchSettings
 */
export interface PortainerLDAPGroupSearchSettings {
    /**
     * LDAP attribute which denotes the group membership
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    groupAttribute?: string;
    /**
     * The distinguished name of the element from which the LDAP server will search for groups
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    groupBaseDN?: string;
    /**
     * The LDAP search filter used to select group elements, optional
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    groupFilter?: string;
}

/**
 * 
 * @export
 * @interface PortainerLDAPSearchSettings
 */
export interface PortainerLDAPSearchSettings {
    /**
     * The distinguished name of the element from which the LDAP server will search for users
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    baseDN?: string;
    /**
     * Optional LDAP search filter used to select user elements
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    filter?: string;
    /**
     * LDAP attribute which denotes the username
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    userNameAttribute?: string;
}

/**
 * 
 * @export
 * @interface PortainerLDAPSettings
 */
export interface PortainerLDAPSettings {
    /**
     * Enable this option if the server is configured for Anonymous access. When enabled, ReaderDN and Password will not be used
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    anonymousMode?: boolean;
    /**
     * Automatically provision users and assign them to matching LDAP group names
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    autoCreateUsers?: boolean;
    /**
     * 
     * @type {Array<PortainerLDAPGroupSearchSettings>}
     * @memberof PortainerLDAPSettings
     */
    groupSearchSettings?: Array<PortainerLDAPGroupSearchSettings>;
    /**
     * Password of the account that will be used to search users
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    password?: string;
    /**
     * Account that will be used to search for users
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    readerDN?: string;
    /**
     * 
     * @type {Array<PortainerLDAPSearchSettings>}
     * @memberof PortainerLDAPSettings
     */
    searchSettings?: Array<PortainerLDAPSearchSettings>;
    /**
     * Whether LDAP connection should use StartTLS
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    startTLS?: boolean;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerLDAPSettings
     */
    tLSConfig?: PortainerTLSConfiguration;
    /**
     * URL or IP address of the LDAP server
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    URL?: string;
}

/**
 * 
 * @export
 * @interface PortainerOAuthSettings
 */
export interface PortainerOAuthSettings {
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    accessTokenURI?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    authorizationURI?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    clientID?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    clientSecret?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerOAuthSettings
     */
    defaultTeamID?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerOAuthSettings
     */
    kubeSecretKey?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    logoutURI?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOAuthSettings
     */
    oAuthAutoCreateUsers?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    redirectURI?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    resourceURI?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOAuthSettings
     */
    SSO?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    scopes?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    userIdentifier?: string;
}

/**
 * 
 * @export
 * @interface PortainerOpenAMTConfiguration
 */
export interface PortainerOpenAMTConfiguration {
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    certFileContent?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    certFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    certFilePassword?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    domainName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTConfiguration
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    mpsPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    mpsServer?: string;
    /**
     * retrieved from API
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    mpsToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    mpsUser?: string;
}

/**
 * 
 * @export
 * @interface PortainerOpenAMTDeviceEnabledFeatures
 */
export interface PortainerOpenAMTDeviceEnabledFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    IDER?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    KVM?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    SOL?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    redirection?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    userConsent?: string;
}

/**
 * 
 * @export
 * @interface PortainerPair
 */
export interface PortainerPair {
    /**
     * 
     * @type {string}
     * @memberof PortainerPair
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerPair
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface PortainerQuayRegistryData
 */
export interface PortainerQuayRegistryData {
    /**
     * 
     * @type {string}
     * @memberof PortainerQuayRegistryData
     */
    organisationName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerQuayRegistryData
     */
    useOrganisation?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerRegistry
 */
export interface PortainerRegistry {
    /**
     * Stores temporary access token
     * @type {string}
     * @memberof PortainerRegistry
     */
    accessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRegistry
     */
    accessTokenExpiry?: number;
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof PortainerRegistry
     */
    authentication?: boolean;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerRegistry
     */
    authorizedTeams?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerRegistry
     */
    authorizedUsers?: Array<number>;
    /**
     * Base URL, introduced for ProGet registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    baseURL?: string;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof PortainerRegistry
     */
    ecr?: PortainerEcrData;
    /**
     * 
     * @type {PortainerGitlabRegistryData}
     * @memberof PortainerRegistry
     */
    gitlab?: PortainerGitlabRegistryData;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof PortainerRegistry
     */
    id?: number;
    /**
     * 
     * @type {PortainerRegistryManagementConfiguration}
     * @memberof PortainerRegistry
     */
    managementConfiguration?: PortainerRegistryManagementConfiguration;
    /**
     * Registry Name
     * @type {string}
     * @memberof PortainerRegistry
     */
    name?: string;
    /**
     * Password or SecretAccessKey used to authenticate against this registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    password?: string;
    /**
     * 
     * @type {PortainerQuayRegistryData}
     * @memberof PortainerRegistry
     */
    quay?: PortainerQuayRegistryData;
    /**
     * 
     * @type {PortainerRegistryAccesses}
     * @memberof PortainerRegistry
     */
    registryAccesses?: PortainerRegistryAccesses;
    /**
     * Deprecated in DBVersion == 31
     * @type {PortainerTeamAccessPolicies}
     * @memberof PortainerRegistry
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)
     * @type {number}
     * @memberof PortainerRegistry
     */
    type?: number;
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    URL?: string;
    /**
     * Deprecated fields Deprecated in DBVersion == 31
     * @type {PortainerUserAccessPolicies}
     * @memberof PortainerRegistry
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
    /**
     * Username or AccessKeyID used to authenticate against this registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface PortainerRegistryAccessPolicies
 */
export interface PortainerRegistryAccessPolicies {
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerRegistryAccessPolicies
     */
    namespaces?: Array<string>;
    /**
     * 
     * @type {PortainerTeamAccessPolicies}
     * @memberof PortainerRegistryAccessPolicies
     */
    teamAccessPolicies?: PortainerTeamAccessPolicies;
    /**
     * 
     * @type {PortainerUserAccessPolicies}
     * @memberof PortainerRegistryAccessPolicies
     */
    userAccessPolicies?: PortainerUserAccessPolicies;
}

/**
 * 
 * @export
 * @interface PortainerRegistryAccesses
 */
export interface PortainerRegistryAccesses {
    [key: string]: PortainerRegistryAccessPolicies;

}

/**
 * 
 * @export
 * @interface PortainerRegistryManagementConfiguration
 */
export interface PortainerRegistryManagementConfiguration {
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    accessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRegistryManagementConfiguration
     */
    accessTokenExpiry?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerRegistryManagementConfiguration
     */
    authentication?: boolean;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof PortainerRegistryManagementConfiguration
     */
    ecr?: PortainerEcrData;
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    password?: string;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerRegistryManagementConfiguration
     */
    tLSConfig?: PortainerTLSConfiguration;
    /**
     * Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)
     * @type {number}
     * @memberof PortainerRegistryManagementConfiguration
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface PortainerResourceControl
 */
export interface PortainerResourceControl {
    /**
     * 
     * @type {number}
     * @memberof PortainerResourceControl
     */
    accessLevel?: number;
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    administratorsOnly?: boolean;
    /**
     * ResourceControl Identifier
     * @type {number}
     * @memberof PortainerResourceControl
     */
    id?: number;
    /**
     * Deprecated fields Deprecated in DBVersion == 2
     * @type {number}
     * @memberof PortainerResourceControl
     */
    ownerId?: number;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    _public?: boolean;
    /**
     * Docker resource identifier on which access control will be applied.\\ In the case of a resource control applied to a stack, use the stack name as identifier
     * @type {string}
     * @memberof PortainerResourceControl
     */
    resourceId?: string;
    /**
     * List of Docker resources that will inherit this access control
     * @type {Array<string>}
     * @memberof PortainerResourceControl
     */
    subResourceIds?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    system?: boolean;
    /**
     * 
     * @type {Array<PortainerTeamResourceAccess>}
     * @memberof PortainerResourceControl
     */
    teamAccesses?: Array<PortainerTeamResourceAccess>;
    /**
     * Type of Docker resource. Valid values are: 1- container, 2 -service 3 - volume, 4 - secret, 5 - stack, 6 - config or 7 - custom template
     * @type {number}
     * @memberof PortainerResourceControl
     */
    type?: number;
    /**
     * 
     * @type {Array<PortainerUserResourceAccess>}
     * @memberof PortainerResourceControl
     */
    userAccesses?: Array<PortainerUserResourceAccess>;
}

/**
 * 
 * @export
 * @interface PortainerRole
 */
export interface PortainerRole {
    /**
     * Authorizations associated to a role
     * @type {PortainerAuthorizations}
     * @memberof PortainerRole
     */
    authorizations?: PortainerAuthorizations;
    /**
     * Role description
     * @type {string}
     * @memberof PortainerRole
     */
    description?: string;
    /**
     * Role Identifier
     * @type {number}
     * @memberof PortainerRole
     */
    id?: number;
    /**
     * Role name
     * @type {string}
     * @memberof PortainerRole
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRole
     */
    priority?: number;
}

/**
 * 
 * @export
 * @interface PortainerSSLSettings
 */
export interface PortainerSSLSettings {
    /**
     * 
     * @type {string}
     * @memberof PortainerSSLSettings
     */
    certPath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSSLSettings
     */
    httpEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerSSLSettings
     */
    keyPath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSSLSettings
     */
    selfSigned?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerSettings
 */
export interface PortainerSettings {
    /**
     * Container environment parameter AGENT_SECRET
     * @type {string}
     * @memberof PortainerSettings
     */
    agentSecret?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowBindMountsForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowContainerCapabilitiesForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowDeviceMappingForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowHostNamespaceForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowPrivilegedModeForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowStackManagementForRegularUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    allowVolumeBrowserForRegularUsers?: boolean;
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof PortainerSettings
     */
    authenticationMethod?: number;
    /**
     * A list of label name & value that will be used to hide containers when querying containers
     * @type {Array<PortainerPair>}
     * @memberof PortainerSettings
     */
    blackListedLabels?: Array<PortainerPair>;
    /**
     * The default check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof PortainerSettings
     */
    edgeAgentCheckinInterval?: number;
    /**
     * EdgePortainerURL is the URL that is exposed to edge agents
     * @type {string}
     * @memberof PortainerSettings
     */
    edgePortainerUrl?: string;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof PortainerSettings
     */
    enableEdgeComputeFeatures?: boolean;
    /**
     * Deprecated fields v26
     * @type {boolean}
     * @memberof PortainerSettings
     */
    enableHostManagementFeatures?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof PortainerSettings
     */
    enableTelemetry?: boolean;
    /**
     * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
     * @type {boolean}
     * @memberof PortainerSettings
     */
    enforceEdgeID?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerSettings
     */
    featureFlagSettings?: { [key: string]: boolean; };
    /**
     * Helm repository URL, defaults to \"https://charts.bitnami.com/bitnami\"
     * @type {string}
     * @memberof PortainerSettings
     */
    helmRepositoryURL?: string;
    /**
     * 
     * @type {PortainerInternalAuthSettings}
     * @memberof PortainerSettings
     */
    internalAuthSettings?: PortainerInternalAuthSettings;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    isDockerDesktopExtension?: boolean;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof PortainerSettings
     */
    kubeconfigExpiry?: string;
    /**
     * KubectlImage, defaults to portainer/kubectl-shell
     * @type {string}
     * @memberof PortainerSettings
     */
    kubectlShellImage?: string;
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof PortainerSettings
     */
    lDAPSettings?: PortainerLDAPSettings;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof PortainerSettings
     */
    logoURL?: string;
    /**
     * 
     * @type {PortainerOAuthSettings}
     * @memberof PortainerSettings
     */
    oAuthSettings?: PortainerOAuthSettings;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof PortainerSettings
     */
    showKomposeBuildOption?: boolean;
    /**
     * The interval in which environment(endpoint) snapshots are created
     * @type {string}
     * @memberof PortainerSettings
     */
    snapshotInterval?: string;
    /**
     * URL to the templates that will be displayed in the UI when navigating to App Templates
     * @type {string}
     * @memberof PortainerSettings
     */
    templatesURL?: string;
    /**
     * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
     * @type {boolean}
     * @memberof PortainerSettings
     */
    trustOnFirstConnect?: boolean;
    /**
     * The duration of a user session
     * @type {string}
     * @memberof PortainerSettings
     */
    userSessionTimeout?: string;
    /**
     * Deprecated fields
     * @type {boolean}
     * @memberof PortainerSettings
     */
    displayDonationHeader?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    displayExternalContributors?: boolean;
    /**
     * 
     * @type {PortainerSettingsEdge}
     * @memberof PortainerSettings
     */
    edge?: PortainerSettingsEdge;
    /**
     * 
     * @type {PortainerFDOConfiguration}
     * @memberof PortainerSettings
     */
    fdoConfiguration?: PortainerFDOConfiguration;
    /**
     * 
     * @type {PortainerOpenAMTConfiguration}
     * @memberof PortainerSettings
     */
    openAMTConfiguration?: PortainerOpenAMTConfiguration;
}

/**
 * 
 * @export
 * @interface PortainerSettingsEdge
 */
export interface PortainerSettingsEdge {
    /**
     * The command list interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    commandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    pingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    snapshotInterval?: number;
    /**
     * Deprecated 2.18
     * @type {boolean}
     * @memberof PortainerSettingsEdge
     */
    asyncMode?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerStack
 */
export interface PortainerStack {
    /**
     * Only applies when deploying stack with multiple files
     * @type {Array<string>}
     * @memberof PortainerStack
     */
    additionalFiles?: Array<string>;
    /**
     * The GitOps update settings of a git stack
     * @type {PortainerAutoUpdateSettings}
     * @memberof PortainerStack
     */
    autoUpdate?: PortainerAutoUpdateSettings;
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof PortainerStack
     */
    EndpointId?: number;
    /**
     * Path to the Stack file
     * @type {string}
     * @memberof PortainerStack
     */
    entryPoint?: string;
    /**
     * A list of environment(endpoint) variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof PortainerStack
     */
    Env?: Array<PortainerPair>;
    /**
     * Stack Identifier
     * @type {number}
     * @memberof PortainerStack
     */
    Id?: number;
    /**
     * Stack name
     * @type {string}
     * @memberof PortainerStack
     */
    Name?: string;
    /**
     * The stack deployment option
     * @type {PortainerStackOption}
     * @memberof PortainerStack
     */
    option?: PortainerStackOption;
    /**
     * 
     * @type {PortainerResourceControl}
     * @memberof PortainerStack
     */
    resourceControl?: PortainerResourceControl;
    /**
     * Stack status (1 - active, 2 - inactive)
     * @type {number}
     * @memberof PortainerStack
     */
    status?: number;
    /**
     * Cluster identifier of the Swarm cluster where the stack is deployed
     * @type {string}
     * @memberof PortainerStack
     */
    swarmId?: string;
    /**
     * Stack type. 1 for a Swarm stack, 2 for a Compose stack
     * @type {number}
     * @memberof PortainerStack
     */
    type?: number;
    /**
     * The username which created this stack
     * @type {string}
     * @memberof PortainerStack
     */
    createdBy?: string;
    /**
     * The date in unix time when stack was created
     * @type {number}
     * @memberof PortainerStack
     */
    creationDate?: number;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof PortainerStack
     */
    fromAppTemplate?: boolean;
    /**
     * The git config of this stack
     * @type {GittypesRepoConfig}
     * @memberof PortainerStack
     */
    gitConfig?: GittypesRepoConfig;
    /**
     * IsComposeFormat indicates if the Kubernetes stack is created from a Docker Compose file
     * @type {boolean}
     * @memberof PortainerStack
     */
    isComposeFormat?: boolean;
    /**
     * Kubernetes namespace if stack is a kube application
     * @type {string}
     * @memberof PortainerStack
     */
    namespace?: string;
    /**
     * Path on disk to the repository hosting the Stack file
     * @type {string}
     * @memberof PortainerStack
     */
    projectPath?: string;
    /**
     * The date in unix time when stack was last updated
     * @type {number}
     * @memberof PortainerStack
     */
    updateDate?: number;
    /**
     * The username which last updated this stack
     * @type {string}
     * @memberof PortainerStack
     */
    updatedBy?: string;
}

/**
 * 
 * @export
 * @interface PortainerStackDeploymentInfo
 */
export interface PortainerStackDeploymentInfo {
    /**
     * ConfigHash is the commit hash of the git repository used for deploying the stack
     * @type {string}
     * @memberof PortainerStackDeploymentInfo
     */
    configHash?: string;
    /**
     * FileVersion is the version of the stack file, used to detect changes
     * @type {number}
     * @memberof PortainerStackDeploymentInfo
     */
    fileVersion?: number;
    /**
     * Version is the version of the stack and also is the deployed version in edge agent
     * @type {number}
     * @memberof PortainerStackDeploymentInfo
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface PortainerStackOption
 */
export interface PortainerStackOption {
    /**
     * Prune services that are no longer referenced
     * @type {boolean}
     * @memberof PortainerStackOption
     */
    prune?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerTLSConfiguration
 */
export interface PortainerTLSConfiguration {
    /**
     * Use TLS
     * @type {boolean}
     * @memberof PortainerTLSConfiguration
     */
    TLS?: boolean;
    /**
     * Path to the TLS CA certificate file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    tLSCACert?: string;
    /**
     * Path to the TLS client certificate file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    tLSCert?: string;
    /**
     * Path to the TLS client key file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    tLSKey?: string;
    /**
     * Skip the verification of the server TLS certificate
     * @type {boolean}
     * @memberof PortainerTLSConfiguration
     */
    tLSSkipVerify?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerTag
 */
export interface PortainerTag {
    /**
     * A set of environment(endpoint) group ids that have this tag
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerTag
     */
    endpointGroups?: { [key: string]: boolean; };
    /**
     * A set of environment(endpoint) ids that have this tag
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerTag
     */
    endpoints?: { [key: string]: boolean; };
    /**
     * Tag name
     * @type {string}
     * @memberof PortainerTag
     */
    name?: string;
    /**
     * Tag identifier
     * @type {number}
     * @memberof PortainerTag
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface PortainerTeam
 */
export interface PortainerTeam {
    /**
     * Team Identifier
     * @type {number}
     * @memberof PortainerTeam
     */
    id?: number;
    /**
     * Team name
     * @type {string}
     * @memberof PortainerTeam
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface PortainerTeamAccessPolicies
 */
export interface PortainerTeamAccessPolicies {
    [key: string]: PortainerAccessPolicy;

}

/**
 * 
 * @export
 * @interface PortainerTeamMembership
 */
export interface PortainerTeamMembership {
    /**
     * Membership Identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    id?: number;
    /**
     * Team role (1 for team leader and 2 for team member)
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    role?: number;
    /**
     * Team identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    teamID?: number;
    /**
     * User identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    userID?: number;
}

/**
 * 
 * @export
 * @interface PortainerTeamResourceAccess
 */
export interface PortainerTeamResourceAccess {
    /**
     * 
     * @type {number}
     * @memberof PortainerTeamResourceAccess
     */
    accessLevel?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerTeamResourceAccess
     */
    teamId?: number;
}

/**
 * 
 * @export
 * @interface PortainerTemplate
 */
export interface PortainerTemplate {
    /**
     * Mandatory container/stack fields Template Identifier
     * @type {number}
     * @memberof PortainerTemplate
     */
    id?: number;
    /**
     * Whether the template should be available to administrators only
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    administratorOnly?: boolean;
    /**
     * A list of categories associated to the template
     * @type {Array<string>}
     * @memberof PortainerTemplate
     */
    categories?: Array<string>;
    /**
     * The command that will be executed in a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    command?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof PortainerTemplate
     */
    description?: string;
    /**
     * A list of environment(endpoint) variables used during the template deployment
     * @type {Array<PortainerTemplateEnv>}
     * @memberof PortainerTemplate
     */
    env?: Array<PortainerTemplateEnv>;
    /**
     * Container hostname
     * @type {string}
     * @memberof PortainerTemplate
     */
    hostname?: string;
    /**
     * Mandatory container fields Image associated to a container template. Mandatory for a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    image?: string;
    /**
     * Whether the container should be started in interactive mode (-i -t equivalent on the CLI)
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    interactive?: boolean;
    /**
     * Container labels
     * @type {Array<PortainerPair>}
     * @memberof PortainerTemplate
     */
    labels?: Array<PortainerPair>;
    /**
     * URL of the template's logo
     * @type {string}
     * @memberof PortainerTemplate
     */
    logo?: string;
    /**
     * Optional stack/container fields Default name for the stack/container to be used on deployment
     * @type {string}
     * @memberof PortainerTemplate
     */
    name?: string;
    /**
     * Name of a network that will be used on container deployment if it exists inside the environment(endpoint)
     * @type {string}
     * @memberof PortainerTemplate
     */
    network?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof PortainerTemplate
     */
    note?: string;
    /**
     * Platform associated to the template. Valid values are: 'linux', 'windows' or leave empty for multi-platform
     * @type {string}
     * @memberof PortainerTemplate
     */
    platform?: string;
    /**
     * A list of ports exposed by the container
     * @type {Array<string>}
     * @memberof PortainerTemplate
     */
    ports?: Array<string>;
    /**
     * Whether the container should be started in privileged mode
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    privileged?: boolean;
    /**
     * Optional container fields The URL of a registry associated to the image for a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    registry?: string;
    /**
     * Mandatory stack fields
     * @type {PortainerTemplateRepository}
     * @memberof PortainerTemplate
     */
    repository?: PortainerTemplateRepository;
    /**
     * Container restart policy
     * @type {string}
     * @memberof PortainerTemplate
     */
    restartPolicy?: string;
    /**
     * Mandatory Edge stack fields Stack file used for this template
     * @type {string}
     * @memberof PortainerTemplate
     */
    stackFile?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof PortainerTemplate
     */
    title?: string;
    /**
     * Template type. Valid values are: 1 (container), 2 (Swarm stack), 3 (Compose stack), 4 (Compose edge stack)
     * @type {number}
     * @memberof PortainerTemplate
     */
    type?: number;
    /**
     * A list of volumes used during the container template deployment
     * @type {Array<PortainerTemplateVolume>}
     * @memberof PortainerTemplate
     */
    volumes?: Array<PortainerTemplateVolume>;
}

/**
 * 
 * @export
 * @interface PortainerTemplateEnv
 */
export interface PortainerTemplateEnv {
    /**
     * Default value that will be set for the variable
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    _default?: string;
    /**
     * Content of the tooltip that will be generated in the UI
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    description?: string;
    /**
     * Text for the label that will be generated in the UI
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    label?: string;
    /**
     * name of the environment(endpoint) variable
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    name?: string;
    /**
     * If set to true, will not generate any input for this variable in the UI
     * @type {boolean}
     * @memberof PortainerTemplateEnv
     */
    preset?: boolean;
    /**
     * A list of name/value that will be used to generate a dropdown in the UI
     * @type {Array<PortainerTemplateEnvSelect>}
     * @memberof PortainerTemplateEnv
     */
    select?: Array<PortainerTemplateEnvSelect>;
}

/**
 * 
 * @export
 * @interface PortainerTemplateEnvSelect
 */
export interface PortainerTemplateEnvSelect {
    /**
     * Will set this choice as the default choice
     * @type {boolean}
     * @memberof PortainerTemplateEnvSelect
     */
    _default?: boolean;
    /**
     * Some text that will displayed as a choice
     * @type {string}
     * @memberof PortainerTemplateEnvSelect
     */
    text?: string;
    /**
     * A value that will be associated to the choice
     * @type {string}
     * @memberof PortainerTemplateEnvSelect
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface PortainerTemplateRepository
 */
export interface PortainerTemplateRepository {
    /**
     * Path to the stack file inside the git repository
     * @type {string}
     * @memberof PortainerTemplateRepository
     */
    stackfile?: string;
    /**
     * URL of a git repository used to deploy a stack template. Mandatory for a Swarm/Compose stack template
     * @type {string}
     * @memberof PortainerTemplateRepository
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface PortainerTemplateVolume
 */
export interface PortainerTemplateVolume {
    /**
     * Path on the host
     * @type {string}
     * @memberof PortainerTemplateVolume
     */
    bind?: string;
    /**
     * Path inside the container
     * @type {string}
     * @memberof PortainerTemplateVolume
     */
    container?: string;
    /**
     * Whether the volume used should be readonly
     * @type {boolean}
     * @memberof PortainerTemplateVolume
     */
    readonly?: boolean;
}

/**
 * 
 * @export
 * @interface PortainerUser
 */
export interface PortainerUser {
    /**
     * User Identifier
     * @type {number}
     * @memberof PortainerUser
     */
    id?: number;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof PortainerUser
     */
    role?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerUser
     */
    tokenIssueAt?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerUser
     */
    username?: string;
    /**
     * Deprecated in DBVersion == 25
     * @type {PortainerEndpointAuthorizations}
     * @memberof PortainerUser
     */
    endpointAuthorizations?: PortainerEndpointAuthorizations;
    /**
     * Deprecated in DBVersion == 25
     * @type {PortainerAuthorizations}
     * @memberof PortainerUser
     */
    portainerAuthorizations?: PortainerAuthorizations;
    /**
     * 
     * @type {PortainerUserThemeSettings}
     * @memberof PortainerUser
     */
    themeSettings?: PortainerUserThemeSettings;
    /**
     * Deprecated
     * @type {string}
     * @memberof PortainerUser
     */
    userTheme?: string;
}

/**
 * 
 * @export
 * @interface PortainerUserAccessPolicies
 */
export interface PortainerUserAccessPolicies {
    [key: string]: PortainerAccessPolicy;

}

/**
 * 
 * @export
 * @interface PortainerUserResourceAccess
 */
export interface PortainerUserResourceAccess {
    /**
     * 
     * @type {number}
     * @memberof PortainerUserResourceAccess
     */
    accessLevel?: number;
    /**
     * User identifier who created this template
     * @type {number}
     * @memberof PortainerUserResourceAccess
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface PortainerUserThemeSettings
 */
export interface PortainerUserThemeSettings {
    /**
     * Color represents the color theme of the UI
     * @type {string}
     * @memberof PortainerUserThemeSettings
     */
    color?: PortainerUserThemeSettings.ColorEnum;
}

/**
 * @export
 * @namespace PortainerUserThemeSettings
 */
export namespace PortainerUserThemeSettings {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        Dark = <any> 'dark',
        Light = <any> 'light',
        Highcontrast = <any> 'highcontrast',
        Auto = <any> 'auto'
    }
}

/**
 * 
 * @export
 * @interface PortainerWebhook
 */
export interface PortainerWebhook {
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof PortainerWebhook
     */
    endpointId?: number;
    /**
     * Webhook Identifier
     * @type {number}
     * @memberof PortainerWebhook
     */
    id?: number;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof PortainerWebhook
     */
    registryId?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerWebhook
     */
    resourceId?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerWebhook
     */
    token?: string;
    /**
     * Type of webhook (1 - service)
     * @type {number}
     * @memberof PortainerWebhook
     */
    type?: number;
}

/**
 * 
 * @export
 * @interface RegistriesRegistryConfigurePayload
 */
export interface RegistriesRegistryConfigurePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    authentication: boolean;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    password?: string;
    /**
     * ECR region
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    region?: string;
    /**
     * Use TLS
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    tls?: boolean;
    /**
     * The TLS CA certificate file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    tlscacertFile?: Array<number>;
    /**
     * The TLS client certificate file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    tlscertFile?: Array<number>;
    /**
     * The TLS client key file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    tlskeyFile?: Array<number>;
    /**
     * Skip the verification of the server TLS certificate
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    tlsskipVerify?: boolean;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface RegistriesRegistryCreatePayload
 */
export interface RegistriesRegistryCreatePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryCreatePayload
     */
    authentication: boolean;
    /**
     * BaseURL required for ProGet registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    baseURL?: string;
    /**
     * ECR specific details, required when type = 7
     * @type {PortainerEcrData}
     * @memberof RegistriesRegistryCreatePayload
     */
    ecr?: PortainerEcrData;
    /**
     * Gitlab specific details, required when type = 4
     * @type {PortainerGitlabRegistryData}
     * @memberof RegistriesRegistryCreatePayload
     */
    gitlab?: PortainerGitlabRegistryData;
    /**
     * Name that will be used to identify this registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    name: string;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    password?: string;
    /**
     * Quay specific details, required when type = 1
     * @type {PortainerQuayRegistryData}
     * @memberof RegistriesRegistryCreatePayload
     */
    quay?: PortainerQuayRegistryData;
    /**
     * Registry Type. Valid values are:  1 (Quay.io),  2 (Azure container registry),  3 (custom registry),  4 (Gitlab registry),  5 (ProGet registry),  6 (DockerHub)  7 (ECR)
     * @type {number}
     * @memberof RegistriesRegistryCreatePayload
     */
    type: number;
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    url: string;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface RegistriesRegistryUpdatePayload
 */
export interface RegistriesRegistryUpdatePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryUpdatePayload
     */
    authentication: boolean;
    /**
     * BaseURL is used for quay registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    baseURL?: string;
    /**
     * ECR data
     * @type {PortainerEcrData}
     * @memberof RegistriesRegistryUpdatePayload
     */
    ecr?: PortainerEcrData;
    /**
     * Name that will be used to identify this registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    name: string;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    password?: string;
    /**
     * Quay data
     * @type {PortainerQuayRegistryData}
     * @memberof RegistriesRegistryUpdatePayload
     */
    quay?: PortainerQuayRegistryData;
    /**
     * Registry access control
     * @type {PortainerRegistryAccesses}
     * @memberof RegistriesRegistryUpdatePayload
     */
    registryAccesses?: PortainerRegistryAccesses;
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    url: string;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    username?: string;
}

/**
 * 
 * @export
 * @interface ReleaseChart
 */
export interface ReleaseChart {
    /**
     * Files are miscellaneous files in a chart archive, e.g. README, LICENSE, etc.
     * @type {Array<ReleaseFile>}
     * @memberof ReleaseChart
     */
    files?: Array<ReleaseFile>;
    /**
     * Lock is the contents of Chart.lock.
     * @type {ReleaseLock}
     * @memberof ReleaseChart
     */
    lock?: ReleaseLock;
    /**
     * Metadata is the contents of the Chartfile.
     * @type {ReleaseMetadata}
     * @memberof ReleaseChart
     */
    metadata?: ReleaseMetadata;
    /**
     * Schema is an optional JSON schema for imposing structure on Values
     * @type {Array<number>}
     * @memberof ReleaseChart
     */
    schema?: Array<number>;
    /**
     * Templates for this chart.
     * @type {Array<ReleaseFile>}
     * @memberof ReleaseChart
     */
    templates?: Array<ReleaseFile>;
    /**
     * Values are default config for this chart.
     * @type {{ [key: string]: any; }}
     * @memberof ReleaseChart
     */
    values?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface ReleaseDependency
 */
export interface ReleaseDependency {
    /**
     * Alias usable alias to be used for the chart
     * @type {string}
     * @memberof ReleaseDependency
     */
    alias?: string;
    /**
     * A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )
     * @type {string}
     * @memberof ReleaseDependency
     */
    condition?: string;
    /**
     * Enabled bool determines if chart should be loaded
     * @type {boolean}
     * @memberof ReleaseDependency
     */
    enabled?: boolean;
    /**
     * ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.
     * @type {Array<any>}
     * @memberof ReleaseDependency
     */
    importValues?: Array<any>;
    /**
     * Name is the name of the dependency.  This must mach the name in the dependency's Chart.yaml.
     * @type {string}
     * @memberof ReleaseDependency
     */
    name?: string;
    /**
     * The URL to the repository.  Appending `index.yaml` to this string should result in a URL that can be used to fetch the repository index.
     * @type {string}
     * @memberof ReleaseDependency
     */
    repository?: string;
    /**
     * Tags can be used to group charts for enabling/disabling together
     * @type {Array<string>}
     * @memberof ReleaseDependency
     */
    tags?: Array<string>;
    /**
     * Version is the version (range) of this chart.  A lock file will always produce a single version, while a dependency may contain a semantic version range.
     * @type {string}
     * @memberof ReleaseDependency
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface ReleaseFile
 */
export interface ReleaseFile {
    /**
     * Data is the template as byte data.
     * @type {Array<number>}
     * @memberof ReleaseFile
     */
    data?: Array<number>;
    /**
     * Name is the path-like name of the template.
     * @type {string}
     * @memberof ReleaseFile
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ReleaseHook
 */
export interface ReleaseHook {
    /**
     * DeletePolicies are the policies that indicate when to delete the hook
     * @type {Array<string>}
     * @memberof ReleaseHook
     */
    deletePolicies?: Array<string>;
    /**
     * Events are the events that this hook fires on.
     * @type {Array<string>}
     * @memberof ReleaseHook
     */
    events?: Array<string>;
    /**
     * Kind is the Kubernetes kind.
     * @type {string}
     * @memberof ReleaseHook
     */
    kind?: string;
    /**
     * LastRun indicates the date/time this was last run.
     * @type {ReleaseHookExecution}
     * @memberof ReleaseHook
     */
    lastRun?: ReleaseHookExecution;
    /**
     * Manifest is the manifest contents.
     * @type {string}
     * @memberof ReleaseHook
     */
    manifest?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseHook
     */
    name?: string;
    /**
     * Path is the chart-relative path to the template.
     * @type {string}
     * @memberof ReleaseHook
     */
    path?: string;
    /**
     * Weight indicates the sort order for execution among similar Hook type
     * @type {number}
     * @memberof ReleaseHook
     */
    weight?: number;
}

/**
 * 
 * @export
 * @interface ReleaseHookExecution
 */
export interface ReleaseHookExecution {
    /**
     * CompletedAt indicates the date/time this hook was completed.
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    completedAt?: string;
    /**
     * Phase indicates whether the hook completed successfully
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    phase?: string;
    /**
     * StartedAt indicates the date/time this hook was started
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    startedAt?: string;
}

/**
 * 
 * @export
 * @interface ReleaseLock
 */
export interface ReleaseLock {
    /**
     * Dependencies is the list of dependencies that this lock file has locked.
     * @type {Array<ReleaseDependency>}
     * @memberof ReleaseLock
     */
    dependencies?: Array<ReleaseDependency>;
    /**
     * Digest is a hash of the dependencies in Chart.yaml.
     * @type {string}
     * @memberof ReleaseLock
     */
    digest?: string;
    /**
     * Generated is the date the lock file was last generated.
     * @type {string}
     * @memberof ReleaseLock
     */
    generated?: string;
}

/**
 * 
 * @export
 * @interface ReleaseMaintainer
 */
export interface ReleaseMaintainer {
    /**
     * Email is an optional email address to contact the named maintainer
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    email?: string;
    /**
     * Name is a user name or organization name
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    name?: string;
    /**
     * URL is an optional URL to an address for the named maintainer
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ReleaseMetadata
 */
export interface ReleaseMetadata {
    /**
     * Annotations are additional mappings uninterpreted by Helm, made available for inspection by other applications.
     * @type {{ [key: string]: string; }}
     * @memberof ReleaseMetadata
     */
    annotations?: { [key: string]: string; };
    /**
     * The API Version of this chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    apiVersion?: string;
    /**
     * The version of the application enclosed inside of this chart.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    appVersion?: string;
    /**
     * The condition to check to enable chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    condition?: string;
    /**
     * Dependencies are a list of dependencies for a chart.
     * @type {Array<ReleaseDependency>}
     * @memberof ReleaseMetadata
     */
    dependencies?: Array<ReleaseDependency>;
    /**
     * Whether or not this chart is deprecated
     * @type {boolean}
     * @memberof ReleaseMetadata
     */
    deprecated?: boolean;
    /**
     * A one-sentence description of the chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    description?: string;
    /**
     * The URL to a relevant project page, git repo, or contact person
     * @type {string}
     * @memberof ReleaseMetadata
     */
    home?: string;
    /**
     * The URL to an icon file.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    icon?: string;
    /**
     * A list of string keywords
     * @type {Array<string>}
     * @memberof ReleaseMetadata
     */
    keywords?: Array<string>;
    /**
     * KubeVersion is a SemVer constraint specifying the version of Kubernetes required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    kubeVersion?: string;
    /**
     * A list of name and URL/email address combinations for the maintainer(s)
     * @type {Array<ReleaseMaintainer>}
     * @memberof ReleaseMetadata
     */
    maintainers?: Array<ReleaseMaintainer>;
    /**
     * The name of the chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    name?: string;
    /**
     * Source is the URL to the source code of this chart
     * @type {Array<string>}
     * @memberof ReleaseMetadata
     */
    sources?: Array<string>;
    /**
     * The tags to check to enable chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    tags?: string;
    /**
     * Specifies the chart type: application or library
     * @type {string}
     * @memberof ReleaseMetadata
     */
    type?: string;
    /**
     * A SemVer 2 conformant version string of the chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface ReleaseRelease
 */
export interface ReleaseRelease {
    /**
     * Info provides information about a release Info *Info `json:\"info,omitempty\"` Chart is the chart that was released.
     * @type {ReleaseChart}
     * @memberof ReleaseRelease
     */
    chart?: ReleaseChart;
    /**
     * Config is the set of extra Values added to the chart. These values override the default values inside of the chart.
     * @type {{ [key: string]: any; }}
     * @memberof ReleaseRelease
     */
    config?: { [key: string]: any; };
    /**
     * Hooks are all of the hooks declared for this release.
     * @type {Array<ReleaseHook>}
     * @memberof ReleaseRelease
     */
    hooks?: Array<ReleaseHook>;
    /**
     * Manifest is the string representation of the rendered template.
     * @type {string}
     * @memberof ReleaseRelease
     */
    manifest?: string;
    /**
     * Name is the name of the release
     * @type {string}
     * @memberof ReleaseRelease
     */
    name?: string;
    /**
     * Namespace is the kubernetes namespace of the release.
     * @type {string}
     * @memberof ReleaseRelease
     */
    namespace?: string;
    /**
     * Version is an int which represents the revision of the release.
     * @type {number}
     * @memberof ReleaseRelease
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface ReleaseReleaseElement
 */
export interface ReleaseReleaseElement {
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    appVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    chart?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    updated?: string;
}

/**
 * 
 * @export
 * @interface ResourceQuantity
 */
export interface ResourceQuantity {
    /**
     * 
     * @type {string}
     * @memberof ResourceQuantity
     */
    format?: string;
}

/**
 * 
 * @export
 * @interface ResourcecontrolsResourceControlCreatePayload
 */
export interface ResourcecontrolsResourceControlCreatePayload {
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    administratorsOnly?: boolean;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    _public?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    resourceID: string;
    /**
     * List of Docker resources that will inherit this access control
     * @type {Array<string>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    subResourceIDs?: Array<string>;
    /**
     * List of team identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    teams?: Array<number>;
    /**
     * Type of Resource. Valid values are: 1 - container, 2 - service 3 - volume, 4 - network, 5 - secret, 6 - stack, 7 - config, 8 - custom template, 9 - azure-container-group
     * @type {number}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    type: number;
    /**
     * List of user identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    users?: Array<number>;
}

/**
 * 
 * @export
 * @interface ResourcecontrolsResourceControlUpdatePayload
 */
export interface ResourcecontrolsResourceControlUpdatePayload {
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    administratorsOnly?: boolean;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    _public?: boolean;
    /**
     * List of team identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    teams?: Array<number>;
    /**
     * List of user identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    users?: Array<number>;
}

/**
 * 
 * @export
 * @interface SettingsPublicSettingsResponse
 */
export interface SettingsPublicSettingsResponse {
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof SettingsPublicSettingsResponse
     */
    authenticationMethod?: number;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    enableEdgeComputeFeatures?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    enableTelemetry?: boolean;
    /**
     * Supported feature flags
     * @type {{ [key: string]: boolean; }}
     * @memberof SettingsPublicSettingsResponse
     */
    features?: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    isDockerDesktopExtension?: boolean;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    logoURL?: string;
    /**
     * The URL used for oauth login
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    oAuthLoginURI?: string;
    /**
     * The URL used for oauth logout
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    oAuthLogoutURI?: string;
    /**
     * The minimum required length for a password of any user when using internal auth mode
     * @type {number}
     * @memberof SettingsPublicSettingsResponse
     */
    requiredPasswordLength?: number;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    showKomposeBuildOption?: boolean;
    /**
     * Whether team sync is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    teamSync?: boolean;
    /**
     * 
     * @type {SettingsPublicSettingsResponseEdge}
     * @memberof SettingsPublicSettingsResponse
     */
    edge?: SettingsPublicSettingsResponseEdge;
    /**
     * Whether AMT is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    isAMTEnabled?: boolean;
    /**
     * Whether FDO is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    isFDOEnabled?: boolean;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    kubeconfigExpiry?: string;
}

/**
 * 
 * @export
 * @interface SettingsPublicSettingsResponseEdge
 */
export interface SettingsPublicSettingsResponseEdge {
    /**
     * The command list interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    commandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    pingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    snapshotInterval?: number;
    /**
     * The check in interval for edge agent (in seconds) - used in non async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    checkinInterval?: number;
}

/**
 * 
 * @export
 * @interface SettingsSettingsUpdatePayload
 */
export interface SettingsSettingsUpdatePayload {
    /**
     * EdgePortainerURL is the URL that is exposed to edge agents
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    edgePortainerURL?: string;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    showKomposeBuildOption?: boolean;
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof SettingsSettingsUpdatePayload
     */
    authenticationMethod?: number;
    /**
     * A list of label name & value that will be used to hide containers when querying containers
     * @type {Array<PortainerPair>}
     * @memberof SettingsSettingsUpdatePayload
     */
    blackListedLabels?: Array<PortainerPair>;
    /**
     * The default check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof SettingsSettingsUpdatePayload
     */
    edgeAgentCheckinInterval?: number;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    enableEdgeComputeFeatures?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    enableTelemetry?: boolean;
    /**
     * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    enforceEdgeID?: boolean;
    /**
     * Helm repository URL
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    helmRepositoryURL?: string;
    /**
     * 
     * @type {PortainerInternalAuthSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    internalAuthSettings?: PortainerInternalAuthSettings;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    kubeconfigExpiry?: string;
    /**
     * Kubectl Shell Image
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    kubectlShellImage?: string;
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    ldapsettings?: PortainerLDAPSettings;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    logoURL?: string;
    /**
     * 
     * @type {PortainerOAuthSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    oauthSettings?: PortainerOAuthSettings;
    /**
     * The interval in which environment(endpoint) snapshots are created
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    snapshotInterval?: string;
    /**
     * URL to the templates that will be displayed in the UI when navigating to App Templates
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    templatesURL?: string;
    /**
     * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    trustOnFirstConnect?: boolean;
    /**
     * The duration of a user session
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    userSessionTimeout?: string;
}

/**
 * 
 * @export
 * @interface SslSslUpdatePayload
 */
export interface SslSslUpdatePayload {
    /**
     * SSL Certificates
     * @type {string}
     * @memberof SslSslUpdatePayload
     */
    cert?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SslSslUpdatePayload
     */
    httpenabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SslSslUpdatePayload
     */
    key?: string;
}

/**
 * 
 * @export
 * @interface StacksComposeStackFromFileContentPayload
 */
export interface StacksComposeStackFromFileContentPayload {
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    env?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    fromAppTemplate?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    name: string;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    stackFileContent: string;
}

/**
 * 
 * @export
 * @interface StacksComposeStackFromGitRepositoryPayload
 */
export interface StacksComposeStackFromGitRepositoryPayload {
    /**
     * Applicable when deploying with multiple stack files
     * @type {Array<string>}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    additionalFiles?: Array<string>;
    /**
     * Optional GitOps update configuration
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    autoUpdate?: PortainerAutoUpdateSettings;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    composeFile?: string;
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    env?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    fromAppTemplate?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    name: string;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    repositoryPassword?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    repositoryReferenceName?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    repositoryURL: string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    repositoryUsername?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    tlsskipVerify?: boolean;
}

/**
 * 
 * @export
 * @interface StacksKubernetesGitDeploymentPayload
 */
export interface StacksKubernetesGitDeploymentPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    additionalFiles?: Array<string>;
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    autoUpdate?: PortainerAutoUpdateSettings;
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    composeFormat?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    manifestFile?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    repositoryPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    repositoryReferenceName?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    repositoryURL?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    repositoryUsername?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    stackName?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    tlsskipVerify?: boolean;
}

/**
 * 
 * @export
 * @interface StacksKubernetesManifestURLDeploymentPayload
 */
export interface StacksKubernetesManifestURLDeploymentPayload {
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    composeFormat?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    manifestURL?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    stackName?: string;
}

/**
 * 
 * @export
 * @interface StacksKubernetesStringDeploymentPayload
 */
export interface StacksKubernetesStringDeploymentPayload {
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    composeFormat?: boolean;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    fromAppTemplate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    stackFileContent?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    stackName?: string;
}

/**
 * 
 * @export
 * @interface StacksStackFileResponse
 */
export interface StacksStackFileResponse {
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksStackFileResponse
     */
    stackFileContent?: string;
}

/**
 * 
 * @export
 * @interface StacksStackGitRedployPayload
 */
export interface StacksStackGitRedployPayload {
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof StacksStackGitRedployPayload
     */
    env?: Array<PortainerPair>;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    prune?: boolean;
    /**
     * Force a pulling to current image with the original tag though the image is already the latest
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    pullImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    repositoryPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    repositoryReferenceName?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    repositoryUsername?: string;
}

/**
 * 
 * @export
 * @interface StacksStackGitUpdatePayload
 */
export interface StacksStackGitUpdatePayload {
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksStackGitUpdatePayload
     */
    autoUpdate?: PortainerAutoUpdateSettings;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof StacksStackGitUpdatePayload
     */
    env?: Array<PortainerPair>;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    prune?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    repositoryAuthentication?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    repositoryPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    repositoryReferenceName?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    repositoryUsername?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    tlsskipVerify?: boolean;
}

/**
 * 
 * @export
 * @interface StacksStackMigratePayload
 */
export interface StacksStackMigratePayload {
    /**
     * Environment(Endpoint) identifier of the target environment(endpoint) where the stack will be relocated
     * @type {number}
     * @memberof StacksStackMigratePayload
     */
    endpointID: number;
    /**
     * If provided will rename the migrated stack
     * @type {string}
     * @memberof StacksStackMigratePayload
     */
    name?: string;
    /**
     * Swarm cluster identifier, must match the identifier of the cluster where the stack will be relocated
     * @type {string}
     * @memberof StacksStackMigratePayload
     */
    swarmID?: string;
}

/**
 * 
 * @export
 * @interface StacksSwarmStackFromFileContentPayload
 */
export interface StacksSwarmStackFromFileContentPayload {
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    env?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    fromAppTemplate?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    name: string;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    stackFileContent: string;
    /**
     * Swarm cluster identifier
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    swarmID: string;
}

/**
 * 
 * @export
 * @interface StacksSwarmStackFromGitRepositoryPayload
 */
export interface StacksSwarmStackFromGitRepositoryPayload {
    /**
     * Applicable when deploying with multiple stack files
     * @type {Array<string>}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    additionalFiles?: Array<string>;
    /**
     * Optional GitOps update configuration
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    autoUpdate?: PortainerAutoUpdateSettings;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    composeFile?: string;
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    env?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    fromAppTemplate?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    name: string;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    repositoryAuthentication?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    repositoryPassword?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    repositoryReferenceName?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    repositoryURL: string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    repositoryUsername?: string;
    /**
     * Swarm cluster identifier
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    swarmID: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    tlsskipVerify?: boolean;
}

/**
 * 
 * @export
 * @interface StacksUpdateSwarmStackPayload
 */
export interface StacksUpdateSwarmStackPayload {
    /**
     * A list of environment(endpoint) variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksUpdateSwarmStackPayload
     */
    env?: Array<PortainerPair>;
    /**
     * Prune services that are no longer referenced (only available for Swarm stacks)
     * @type {boolean}
     * @memberof StacksUpdateSwarmStackPayload
     */
    prune?: boolean;
    /**
     * Force a pulling to current image with the original tag though the image is already the latest
     * @type {boolean}
     * @memberof StacksUpdateSwarmStackPayload
     */
    pullImage?: boolean;
    /**
     * New content of the Stack file
     * @type {string}
     * @memberof StacksUpdateSwarmStackPayload
     */
    stackFileContent?: string;
}

/**
 * 
 * @export
 * @interface SystemBuildInfo
 */
export interface SystemBuildInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    buildNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    goVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    imageTag?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    nodejsVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    webpackVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    yarnVersion?: string;
}

/**
 * 
 * @export
 * @interface SystemNodesCountResponse
 */
export interface SystemNodesCountResponse {
    /**
     * 
     * @type {number}
     * @memberof SystemNodesCountResponse
     */
    nodes?: number;
}

/**
 * 
 * @export
 * @interface SystemStatus
 */
export interface SystemStatus {
    /**
     * Portainer API version
     * @type {string}
     * @memberof SystemStatus
     */
    version?: string;
    /**
     * 
     * @type {DemoEnvironmentDetails}
     * @memberof SystemStatus
     */
    demoEnvironment?: DemoEnvironmentDetails;
    /**
     * Server Instance ID
     * @type {string}
     * @memberof SystemStatus
     */
    instanceID?: string;
}

/**
 * 
 * @export
 * @interface SystemSystemInfoResponse
 */
export interface SystemSystemInfoResponse {
    /**
     * 
     * @type {number}
     * @memberof SystemSystemInfoResponse
     */
    agents?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemSystemInfoResponse
     */
    edgeAgents?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemSystemInfoResponse
     */
    platform?: string;
}

/**
 * 
 * @export
 * @interface SystemVersionResponse
 */
export interface SystemVersionResponse {
    /**
     * The latest version available
     * @type {string}
     * @memberof SystemVersionResponse
     */
    latestVersion?: string;
    /**
     * Whether portainer has an update available
     * @type {boolean}
     * @memberof SystemVersionResponse
     */
    updateAvailable?: boolean;
    /**
     * 
     * @type {SystemBuildInfo}
     * @memberof SystemVersionResponse
     */
    build?: SystemBuildInfo;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionResponse
     */
    databaseVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionResponse
     */
    serverVersion?: string;
}

/**
 * 
 * @export
 * @interface TagsTagCreatePayload
 */
export interface TagsTagCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof TagsTagCreatePayload
     */
    name: string;
}

/**
 * 
 * @export
 * @interface TeammembershipsTeamMembershipCreatePayload
 */
export interface TeammembershipsTeamMembershipCreatePayload {
    /**
     * Role for the user inside the team (1 for leader and 2 for regular member)
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    role: number;
    /**
     * Team identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    teamID: number;
    /**
     * User identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    userID: number;
}

/**
 * 
 * @export
 * @interface TeammembershipsTeamMembershipUpdatePayload
 */
export interface TeammembershipsTeamMembershipUpdatePayload {
    /**
     * Role for the user inside the team (1 for leader and 2 for regular member)
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    role: number;
    /**
     * Team identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    teamID: number;
    /**
     * User identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    userID: number;
}

/**
 * 
 * @export
 * @interface TeamsTeamCreatePayload
 */
export interface TeamsTeamCreatePayload {
    /**
     * Name
     * @type {string}
     * @memberof TeamsTeamCreatePayload
     */
    name: string;
    /**
     * TeamLeaders
     * @type {Array<number>}
     * @memberof TeamsTeamCreatePayload
     */
    teamLeaders?: Array<number>;
}

/**
 * 
 * @export
 * @interface TeamsTeamUpdatePayload
 */
export interface TeamsTeamUpdatePayload {
    /**
     * Name
     * @type {string}
     * @memberof TeamsTeamUpdatePayload
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface TemplatesFilePayload
 */
export interface TemplatesFilePayload {
    /**
     * Path to the file inside the git repository
     * @type {string}
     * @memberof TemplatesFilePayload
     */
    composeFilePathInRepository: string;
    /**
     * URL of a git repository where the file is stored
     * @type {string}
     * @memberof TemplatesFilePayload
     */
    repositoryURL: string;
}

/**
 * 
 * @export
 * @interface TemplatesFileResponse
 */
export interface TemplatesFileResponse {
    /**
     * The requested file content
     * @type {string}
     * @memberof TemplatesFileResponse
     */
    fileContent?: string;
}

/**
 * 
 * @export
 * @interface TemplatesListResponse
 */
export interface TemplatesListResponse {
    /**
     * 
     * @type {Array<PortainerTemplate>}
     * @memberof TemplatesListResponse
     */
    templates?: Array<PortainerTemplate>;
    /**
     * 
     * @type {string}
     * @memberof TemplatesListResponse
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface UsersAccessTokenResponse
 */
export interface UsersAccessTokenResponse {
    /**
     * 
     * @type {PortainerAPIKey}
     * @memberof UsersAccessTokenResponse
     */
    apiKey?: PortainerAPIKey;
    /**
     * 
     * @type {string}
     * @memberof UsersAccessTokenResponse
     */
    rawAPIKey?: string;
}

/**
 * 
 * @export
 * @interface UsersAdminInitPayload
 */
export interface UsersAdminInitPayload {
    /**
     * Password for the admin user
     * @type {string}
     * @memberof UsersAdminInitPayload
     */
    password: string;
    /**
     * Username for the admin user
     * @type {string}
     * @memberof UsersAdminInitPayload
     */
    username: string;
}

/**
 * 
 * @export
 * @interface UsersThemePayload
 */
export interface UsersThemePayload {
    /**
     * Color represents the color theme of the UI
     * @type {string}
     * @memberof UsersThemePayload
     */
    color?: UsersThemePayload.ColorEnum;
}

/**
 * @export
 * @namespace UsersThemePayload
 */
export namespace UsersThemePayload {
    /**
     * @export
     * @enum {string}
     */
    export enum ColorEnum {
        Dark = <any> 'dark',
        Light = <any> 'light',
        Highcontrast = <any> 'highcontrast',
        Auto = <any> 'auto'
    }
}

/**
 * 
 * @export
 * @interface UsersUserAccessTokenCreatePayload
 */
export interface UsersUserAccessTokenCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserAccessTokenCreatePayload
     */
    description: string;
}

/**
 * 
 * @export
 * @interface UsersUserCreatePayload
 */
export interface UsersUserCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserCreatePayload
     */
    password: string;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof UsersUserCreatePayload
     */
    role: number;
    /**
     * 
     * @type {string}
     * @memberof UsersUserCreatePayload
     */
    username: string;
}

/**
 * 
 * @export
 * @interface UsersUserUpdatePasswordPayload
 */
export interface UsersUserUpdatePasswordPayload {
    /**
     * New Password
     * @type {string}
     * @memberof UsersUserUpdatePasswordPayload
     */
    newPassword: string;
    /**
     * Current Password
     * @type {string}
     * @memberof UsersUserUpdatePasswordPayload
     */
    password: string;
}

/**
 * 
 * @export
 * @interface UsersUserUpdatePayload
 */
export interface UsersUserUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    password: string;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof UsersUserUpdatePayload
     */
    role: number;
    /**
     * 
     * @type {UsersThemePayload}
     * @memberof UsersUserUpdatePayload
     */
    theme?: UsersThemePayload;
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    username: string;
}

/**
 * 
 * @export
 * @interface V1Duration
 */
export interface V1Duration {
    /**
     * 
     * @type {number}
     * @memberof V1Duration
     */
    timeDuration?: number;
}

/**
 * 
 * @export
 * @interface V1FieldsV1
 */
export interface V1FieldsV1 {
}

/**
 * 
 * @export
 * @interface V1ManagedFieldsEntry
 */
export interface V1ManagedFieldsEntry {
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    apiVersion?: string;
    /**
     * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    fieldsType?: string;
    /**
     * FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type. +optional
     * @type {V1FieldsV1}
     * @memberof V1ManagedFieldsEntry
     */
    fieldsV1?: V1FieldsV1;
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    manager?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    operation?: string;
    /**
     * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    subresource?: string;
    /**
     * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over. +optional
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    time?: string;
}

/**
 * 
 * @export
 * @interface V1OwnerReference
 */
export interface V1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof V1OwnerReference
     */
    apiVersion?: string;
    /**
     * If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
     * @type {boolean}
     * @memberof V1OwnerReference
     */
    blockOwnerDeletion?: boolean;
    /**
     * If true, this reference points to the managing controller. +optional
     * @type {boolean}
     * @memberof V1OwnerReference
     */
    controller?: boolean;
    /**
     * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * @type {string}
     * @memberof V1OwnerReference
     */
    kind?: string;
    /**
     * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * @type {string}
     * @memberof V1OwnerReference
     */
    name?: string;
    /**
     * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * @type {string}
     * @memberof V1OwnerReference
     */
    uid?: string;
}

/**
 * 
 * @export
 * @interface V1ResourceList
 */
export interface V1ResourceList {
    [key: string]: ResourceQuantity;

}

/**
 * 
 * @export
 * @interface V1beta1ContainerMetrics
 */
export interface V1beta1ContainerMetrics {
    /**
     * Container name corresponding to the one from pod.spec.containers.
     * @type {string}
     * @memberof V1beta1ContainerMetrics
     */
    name?: string;
    /**
     * The memory usage is the memory working set.
     * @type {V1ResourceList}
     * @memberof V1beta1ContainerMetrics
     */
    usage?: V1ResourceList;
}

/**
 * 
 * @export
 * @interface V1beta1NodeMetrics
 */
export interface V1beta1NodeMetrics {
    /**
     * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1NodeMetrics
     */
    annotations?: { [key: string]: string; };
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    apiVersion?: string;
    /**
     * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    creationTimestamp?: string;
    /**
     * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
     * @type {number}
     * @memberof V1beta1NodeMetrics
     */
    deletionGracePeriodSeconds?: number;
    /**
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    deletionTimestamp?: string;
    /**
     * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
     * @type {Array<string>}
     * @memberof V1beta1NodeMetrics
     */
    finalizers?: Array<string>;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will return a 409.  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    generateName?: string;
    /**
     * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
     * @type {number}
     * @memberof V1beta1NodeMetrics
     */
    generation?: number;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    kind?: string;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1NodeMetrics
     */
    labels?: { [key: string]: string; };
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<V1ManagedFieldsEntry>}
     * @memberof V1beta1NodeMetrics
     */
    managedFields?: Array<V1ManagedFieldsEntry>;
    /**
     * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    name?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    namespace?: string;
    /**
     * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
     * @type {Array<V1OwnerReference>}
     * @memberof V1beta1NodeMetrics
     */
    ownerReferences?: Array<V1OwnerReference>;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    resourceVersion?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    selfLink?: string;
    /**
     * The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    timestamp?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    uid?: string;
    /**
     * The memory usage is the memory working set.
     * @type {V1ResourceList}
     * @memberof V1beta1NodeMetrics
     */
    usage?: V1ResourceList;
    /**
     * 
     * @type {V1Duration}
     * @memberof V1beta1NodeMetrics
     */
    window?: V1Duration;
}

/**
 * 
 * @export
 * @interface V1beta1NodeMetricsList
 */
export interface V1beta1NodeMetricsList {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    apiVersion?: string;
    /**
     * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    _continue?: string;
    /**
     * List of node metrics.
     * @type {Array<V1beta1NodeMetrics>}
     * @memberof V1beta1NodeMetricsList
     */
    items?: Array<V1beta1NodeMetrics>;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    kind?: string;
    /**
     * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. +optional
     * @type {number}
     * @memberof V1beta1NodeMetricsList
     */
    remainingItemCount?: number;
    /**
     * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    resourceVersion?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    selfLink?: string;
}

/**
 * 
 * @export
 * @interface V1beta1PodMetrics
 */
export interface V1beta1PodMetrics {
    /**
     * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1PodMetrics
     */
    annotations?: { [key: string]: string; };
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    apiVersion?: string;
    /**
     * Metrics for all containers are collected within the same time window.
     * @type {Array<V1beta1ContainerMetrics>}
     * @memberof V1beta1PodMetrics
     */
    containers?: Array<V1beta1ContainerMetrics>;
    /**
     * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    creationTimestamp?: string;
    /**
     * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
     * @type {number}
     * @memberof V1beta1PodMetrics
     */
    deletionGracePeriodSeconds?: number;
    /**
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    deletionTimestamp?: string;
    /**
     * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
     * @type {Array<string>}
     * @memberof V1beta1PodMetrics
     */
    finalizers?: Array<string>;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will return a 409.  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    generateName?: string;
    /**
     * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
     * @type {number}
     * @memberof V1beta1PodMetrics
     */
    generation?: number;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    kind?: string;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1PodMetrics
     */
    labels?: { [key: string]: string; };
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<V1ManagedFieldsEntry>}
     * @memberof V1beta1PodMetrics
     */
    managedFields?: Array<V1ManagedFieldsEntry>;
    /**
     * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    name?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    namespace?: string;
    /**
     * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
     * @type {Array<V1OwnerReference>}
     * @memberof V1beta1PodMetrics
     */
    ownerReferences?: Array<V1OwnerReference>;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    resourceVersion?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    selfLink?: string;
    /**
     * The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    timestamp?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    uid?: string;
    /**
     * 
     * @type {V1Duration}
     * @memberof V1beta1PodMetrics
     */
    window?: V1Duration;
}

/**
 * 
 * @export
 * @interface V1beta1PodMetricsList
 */
export interface V1beta1PodMetricsList {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    apiVersion?: string;
    /**
     * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    _continue?: string;
    /**
     * List of pod metrics.
     * @type {Array<V1beta1PodMetrics>}
     * @memberof V1beta1PodMetricsList
     */
    items?: Array<V1beta1PodMetrics>;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    kind?: string;
    /**
     * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. +optional
     * @type {number}
     * @memberof V1beta1PodMetricsList
     */
    remainingItemCount?: number;
    /**
     * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    resourceVersion?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    selfLink?: string;
}

/**
 * 
 * @export
 * @interface WebhooksWebhookCreatePayload
 */
export interface WebhooksWebhookCreatePayload {
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    endpointID?: number;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    registryID?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhooksWebhookCreatePayload
     */
    resourceID?: string;
    /**
     * Type of webhook (1 - service)
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    webhookType?: number;
}

/**
 * 
 * @export
 * @interface WebhooksWebhookUpdatePayload
 */
export interface WebhooksWebhookUpdatePayload {
    /**
     * Registry Identifier
     * @type {number}
     * @memberof WebhooksWebhookUpdatePayload
     */
    registryID?: number;
}


/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body: AuthAuthenticatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authenticateUser.');
            }
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthAuthenticatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body: AuthOauthPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validateOAuth.');
            }
            const localVarPath = `/auth/oauth/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthOauthPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body: AuthAuthenticatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthAuthenticateResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authenticateUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body: AuthOauthPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthAuthenticateResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).validateOAuth(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body: AuthAuthenticatePayload, options?: any) {
            return AuthApiFp(configuration).authenticateUser(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return AuthApiFp(configuration).logout(options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body: AuthOauthPayload, options?: any) {
            return AuthApiFp(configuration).validateOAuth(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
     * @summary Authenticate
     * @param {AuthAuthenticatePayload} body Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticateUser(body: AuthAuthenticatePayload, options?: any) {
        return AuthApiFp(this.configuration).authenticateUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: any) {
        return AuthApiFp(this.configuration).logout(options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Authenticate with OAuth
     * @param {AuthOauthPayload} body OAuth Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public validateOAuth(body: AuthOauthPayload, options?: any) {
        return AuthApiFp(this.configuration).validateOAuth(body, options)(this.fetch, this.basePath);
    }

}

/**
 * BackupApi - fetch parameter creator
 * @export
 */
export const BackupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body?: BackupBackupPayload, options: any = {}): FetchArgs {
            const localVarPath = `/backup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BackupBackupPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload: BackupRestorePayload, options: any = {}): FetchArgs {
            // verify required parameter 'restorePayload' is not null or undefined
            if (restorePayload === null || restorePayload === undefined) {
                throw new RequiredError('restorePayload','Required parameter restorePayload was null or undefined when calling restore.');
            }
            const localVarPath = `/restore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BackupRestorePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(restorePayload || {}) : (restorePayload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupApi - functional programming interface
 * @export
 */
export const BackupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body?: BackupBackupPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BackupApiFetchParamCreator(configuration).backup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload: BackupRestorePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BackupApiFetchParamCreator(configuration).restore(restorePayload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BackupApi - factory interface
 * @export
 */
export const BackupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body?: BackupBackupPayload, options?: any) {
            return BackupApiFp(configuration).backup(body, options)(fetch, basePath);
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload: BackupRestorePayload, options?: any) {
            return BackupApiFp(configuration).restore(restorePayload, options)(fetch, basePath);
        },
    };
};

/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
export class BackupApi extends BaseAPI {
    /**
     * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
     * @summary Creates an archive with a system data snapshot that could be used to restore the system.
     * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public backup(body?: BackupBackupPayload, options?: any) {
        return BackupApiFp(this.configuration).backup(body, options)(this.fetch, this.basePath);
    }

    /**
     * Triggers a system restore using provided backup file **Access policy**: public
     * @summary Triggers a system restore using provided backup file
     * @param {BackupRestorePayload} restorePayload Restore request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public restore(restorePayload: BackupRestorePayload, options?: any) {
        return BackupApiFp(this.configuration).restore(restorePayload, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomTemplatesApi - fetch parameter creator
 * @export
 */
export const CustomTemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method: 'string' | 'file' | 'repository', body: any, options: any = {}): FetchArgs {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling customTemplateCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customTemplateCreate.');
            }
            const localVarPath = `/custom_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: any, logo?: string, variables?: string, options: any = {}): FetchArgs {
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title','Required parameter title was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'note' is not null or undefined
            if (note === null || note === undefined) {
                throw new RequiredError('note','Required parameter note was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'platform' is not null or undefined
            if (platform === null || platform === undefined) {
                throw new RequiredError('platform','Required parameter platform was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling customTemplateCreateFile.');
            }
            const localVarPath = `/custom_templates/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (title !== undefined) {
                localVarFormParams.set('Title', title as any);
            }

            if (description !== undefined) {
                localVarFormParams.set('Description', description as any);
            }

            if (note !== undefined) {
                localVarFormParams.set('Note', note as any);
            }

            if (platform !== undefined) {
                localVarFormParams.set('Platform', platform as any);
            }

            if (type !== undefined) {
                localVarFormParams.set('Type', type as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('File', file as any);
            }

            if (logo !== undefined) {
                localVarFormParams.set('Logo', logo as any);
            }

            if (variables !== undefined) {
                localVarFormParams.set('Variables', variables as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customTemplateCreateRepository.');
            }
            const localVarPath = `/custom_templates/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomtemplatesCustomTemplateFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customTemplateCreateString.');
            }
            const localVarPath = `/custom_templates/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomtemplatesCustomTemplateFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customTemplateDelete.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customTemplateFile.');
            }
            const localVarPath = `/custom_templates/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customTemplateGitFetch.');
            }
            const localVarPath = `/custom_templates/{id}/git_fetch`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customTemplateInspect.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling customTemplateList.');
            }
            const localVarPath = `/custom_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling customTemplateUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customTemplateUpdate.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomtemplatesCustomTemplateUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomTemplatesApi - functional programming interface
 * @export
 */
export const CustomTemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method: 'string' | 'file' | 'repository', body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateCreate(method, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: any, logo?: string, variables?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateCreateRepository(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateCreateString(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomtemplatesFileResponse> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomtemplatesFileResponse> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateGitFetch(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerCustomTemplate>> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateList(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerCustomTemplate> {
            const localVarFetchArgs = CustomTemplatesApiFetchParamCreator(configuration).customTemplateUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomTemplatesApi - factory interface
 * @export
 */
export const CustomTemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method: 'string' | 'file' | 'repository', body: any, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateCreate(method, body, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: any, logo?: string, variables?: string, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateCreateRepository(body, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateCreateString(body, options)(fetch, basePath);
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id: number, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id: number, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateFile(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id: number, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateGitFetch(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id: number, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateInspect(id, options)(fetch, basePath);
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type: Array<number>, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateList(type, options)(fetch, basePath);
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: any) {
            return CustomTemplatesApiFp(configuration).customTemplateUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * CustomTemplatesApi - object-oriented interface
 * @export
 * @class CustomTemplatesApi
 * @extends {BaseAPI}
 */
export class CustomTemplatesApi extends BaseAPI {
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {'string' | 'file' | 'repository'} method method for creating template
     * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreate(method: 'string' | 'file' | 'repository', body: any, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreate(method, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {string} title Title of the template
     * @param {string} description Description of the template
     * @param {string} note A note that will be displayed in the UI. Supports HTML content
     * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
     * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
     * @param {any} file File
     * @param {string} [logo] URL of the template&#39;s logo
     * @param {string} [variables] A json array of variables definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: any, logo?: string, variables?: string, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options)(this.fetch, this.basePath);
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateRepository(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateString(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a template. **Access policy**: authenticated
     * @summary Remove a template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateDelete(id: number, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
     * @summary Get Template stack file content.
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateFile(id: number, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a template created from git repository method. **Access policy**: authenticated
     * @summary Fetch the latest config file content based on custom template's git repository configuration
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateGitFetch(id: number, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateGitFetch(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a template. **Access policy**: authenticated
     * @summary Inspect a custom template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateInspect(id: number, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List available custom templates. **Access policy**: authenticated
     * @summary List available custom templates
     * @param {Array<number>} type Template types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateList(type: Array<number>, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateList(type, options)(this.fetch, this.basePath);
    }

    /**
     * Update a template. **Access policy**: authenticated
     * @summary Update a template
     * @param {number} id Template identifier
     * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: any) {
        return CustomTemplatesApiFp(this.configuration).customTemplateUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DockerApi - fetch parameter creator
 * @export
 */
export const DockerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId: number, containerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'environmentId' is not null or undefined
            if (environmentId === null || environmentId === undefined) {
                throw new RequiredError('environmentId','Required parameter environmentId was null or undefined when calling dockerContainerGpusInspect.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling dockerContainerGpusInspect.');
            }
            const localVarPath = `/docker/{environmentId}/containers/{containerId}/gpus`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DockerApi - functional programming interface
 * @export
 */
export const DockerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId: number, containerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContainersContainerGpusResponse> {
            const localVarFetchArgs = DockerApiFetchParamCreator(configuration).dockerContainerGpusInspect(environmentId, containerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DockerApi - factory interface
 * @export
 */
export const DockerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId: number, containerId: number, options?: any) {
            return DockerApiFp(configuration).dockerContainerGpusInspect(environmentId, containerId, options)(fetch, basePath);
        },
    };
};

/**
 * DockerApi - object-oriented interface
 * @export
 * @class DockerApi
 * @extends {BaseAPI}
 */
export class DockerApi extends BaseAPI {
    /**
     * **Access policy**:
     * @summary Fetch container gpus data
     * @param {number} environmentId Environment identifier
     * @param {number} containerId Container identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DockerApi
     */
    public dockerContainerGpusInspect(environmentId: number, containerId: number, options?: any) {
        return DockerApiFp(this.configuration).dockerContainerGpusInspect(environmentId, containerId, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeApi - fetch parameter creator
 * @export
 */
export const EdgeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            // verify required parameter 'jobID' is not null or undefined
            if (jobID === null || jobID === undefined) {
                throw new RequiredError('jobID','Required parameter jobID was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId','Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeApi - functional programming interface
 * @export
 */
export const EdgeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeApiFetchParamCreator(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeStackPayload> {
            const localVarFetchArgs = EdgeApiFetchParamCreator(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeApi - factory interface
 * @export
 */
export const EdgeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any) {
            return EdgeApiFp(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
            return EdgeApiFp(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};

/**
 * EdgeApi - object-oriented interface
 * @export
 * @class EdgeApi
 * @extends {BaseAPI}
 */
export class EdgeApi extends BaseAPI {
    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    public endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any) {
        return EdgeApiFp(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
        return EdgeApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeGroupsApi - fetch parameter creator
 * @export
 */
export const EdgeGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeGroupCreate.');
            }
            const localVarPath = `/edge_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgegroupsEdgeGroupCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeGroupDelete.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeGroupInspect.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options: any = {}): FetchArgs {
            const localVarPath = `/edge_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling egeGroupUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling egeGroupUpdate.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgegroupsEdgeGroupUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeGroupsApi - functional programming interface
 * @export
 */
export const EdgeGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeGroupsApiFetchParamCreator(configuration).edgeGroupCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeGroupsApiFetchParamCreator(configuration).edgeGroupDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeGroupsApiFetchParamCreator(configuration).edgeGroupInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EdgegroupsDecoratedEdgeGroup>> {
            const localVarFetchArgs = EdgeGroupsApiFetchParamCreator(configuration).edgeGroupList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeGroupsApiFetchParamCreator(configuration).egeGroupUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeGroupsApi - factory interface
 * @export
 */
export const EdgeGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: any) {
            return EdgeGroupsApiFp(configuration).edgeGroupCreate(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id: number, options?: any) {
            return EdgeGroupsApiFp(configuration).edgeGroupDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id: number, options?: any) {
            return EdgeGroupsApiFp(configuration).edgeGroupInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options?: any) {
            return EdgeGroupsApiFp(configuration).edgeGroupList(options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: any) {
            return EdgeGroupsApiFp(configuration).egeGroupUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * EdgeGroupsApi - object-oriented interface
 * @export
 * @class EdgeGroupsApi
 * @extends {BaseAPI}
 */
export class EdgeGroupsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeGroup
     * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: any) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Deletes an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupDelete(id: number, options?: any) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Inspects an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupInspect(id: number, options?: any) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary list EdgeGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupList(options?: any) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupList(options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Updates an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: any) {
        return EdgeGroupsApiFp(this.configuration).egeGroupUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeJobsApi - fetch parameter creator
 * @export
 */
export const EdgeJobsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method: 'file' | 'string', body: any, options: any = {}): FetchArgs {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling edgeJobCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeJobCreate.');
            }
            const localVarPath = `/edge_jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file: any, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'cronExpression' is not null or undefined
            if (cronExpression === null || cronExpression === undefined) {
                throw new RequiredError('cronExpression','Required parameter cronExpression was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'edgeGroups' is not null or undefined
            if (edgeGroups === null || edgeGroups === undefined) {
                throw new RequiredError('edgeGroups','Required parameter edgeGroups was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'endpoints' is not null or undefined
            if (endpoints === null || endpoints === undefined) {
                throw new RequiredError('endpoints','Required parameter endpoints was null or undefined when calling edgeJobCreateFile.');
            }
            const localVarPath = `/edge_jobs/create/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (cronExpression !== undefined) {
                localVarFormParams.set('CronExpression', cronExpression as any);
            }

            if (edgeGroups !== undefined) {
                localVarFormParams.set('EdgeGroups', edgeGroups as any);
            }

            if (endpoints !== undefined) {
                localVarFormParams.set('Endpoints', endpoints as any);
            }

            if (recurring !== undefined) {
                localVarFormParams.set('Recurring', recurring as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeJobCreateString.');
            }
            const localVarPath = `/edge_jobs/create/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgejobsEdgeJobCreateFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobDelete.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobFile.');
            }
            const localVarPath = `/edge_jobs/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobInspect.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options: any = {}): FetchArgs {
            const localVarPath = `/edge_jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id: number, taskID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobTaskLogsInspect.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling edgeJobTaskLogsInspect.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id: number, taskID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobTasksClear.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling edgeJobTasksClear.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id: number, taskID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobTasksCollect.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID','Required parameter taskID was null or undefined when calling edgeJobTasksCollect.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobTasksList.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeJobUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeJobUpdate.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgejobsEdgeJobUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeJobsApi - functional programming interface
 * @export
 */
export const EdgeJobsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method: 'file' | 'string', body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobCreate(method, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file: any, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeGroup> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobCreateString(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgejobsEdgeJobFileResponse> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeJob> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerEdgeJob>> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id: number, taskID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgejobsFileResponse> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobTaskLogsInspect(id, taskID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id: number, taskID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobTasksClear(id, taskID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id: number, taskID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobTasksCollect(id, taskID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EdgejobsTaskContainer>> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobTasksList(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeJob> {
            const localVarFetchArgs = EdgeJobsApiFetchParamCreator(configuration).edgeJobUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeJobsApi - factory interface
 * @export
 */
export const EdgeJobsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method: 'file' | 'string', body: any, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobCreate(method, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file: any, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobCreateString(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobFile(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobList(options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id: number, taskID: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobTaskLogsInspect(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id: number, taskID: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobTasksClear(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id: number, taskID: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobTasksCollect(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id: number, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobTasksList(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: any) {
            return EdgeJobsApiFp(configuration).edgeJobUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * EdgeJobsApi - object-oriented interface
 * @export
 * @class EdgeJobsApi
 * @extends {BaseAPI}
 */
export class EdgeJobsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob
     * @param {'file' | 'string'} method Creation Method
     * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreate(method: 'file' | 'string', body: any, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreate(method, body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a file
     * @param {any} file Content of the Stack file
     * @param {string} name Name of the stack
     * @param {string} cronExpression A cron expression to schedule this job
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {string} endpoints JSON stringified array of Environment ids
     * @param {boolean} [recurring] If recurring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreateFile(file: any, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a text
     * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreateString(body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobDelete(id: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch a file of an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobFile(id: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobInspect(id: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch EdgeJobs list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobList(options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobList(options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTaskLogsInspect(id: number, taskID: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobTaskLogsInspect(id, taskID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Clear the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksClear(id: number, taskID: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksClear(id, taskID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Collect the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksCollect(id: number, taskID: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksCollect(id, taskID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch the list of tasks on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksList(id: number, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksList(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Update an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: any) {
        return EdgeJobsApiFp(this.configuration).edgeJobUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeStacksApi - fetch parameter creator
 * @export
 */
export const EdgeStacksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method: 'file' | 'string' | 'repository', body: any, options: any = {}): FetchArgs {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling edgeStackCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeStackCreate.');
            }
            const localVarPath = `/edge_stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name: string, file: any, edgeGroups: string, deploymentType: number, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, dryrun?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'edgeGroups' is not null or undefined
            if (edgeGroups === null || edgeGroups === undefined) {
                throw new RequiredError('edgeGroups','Required parameter edgeGroups was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'deploymentType' is not null or undefined
            if (deploymentType === null || deploymentType === undefined) {
                throw new RequiredError('deploymentType','Required parameter deploymentType was null or undefined when calling edgeStackCreateFile.');
            }
            const localVarPath = `/edge_stacks/create/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (edgeGroups !== undefined) {
                localVarFormParams.set('EdgeGroups', edgeGroups as any);
            }

            if (deploymentType !== undefined) {
                localVarFormParams.set('DeploymentType', deploymentType as any);
            }

            if (registries !== undefined) {
                localVarFormParams.set('Registries', registries as any);
            }

            if (useManifestNamespaces !== undefined) {
                localVarFormParams.set('UseManifestNamespaces', useManifestNamespaces as any);
            }

            if (prePullImage !== undefined) {
                localVarFormParams.set('PrePullImage', prePullImage as any);
            }

            if (retryDeploy !== undefined) {
                localVarFormParams.set('RetryDeploy', retryDeploy as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(method: 'file' | 'string' | 'repository', body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options: any = {}): FetchArgs {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling edgeStackCreateRepository.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeStackCreateRepository.');
            }
            const localVarPath = `/edge_stacks/create/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgestacksEdgeStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeStackCreateString.');
            }
            const localVarPath = `/edge_stacks/create/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgestacksEdgeStackFromStringPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackDelete.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackFile.');
            }
            const localVarPath = `/edge_stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackInspect.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options: any = {}): FetchArgs {
            const localVarPath = `/edge_stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id: number, environmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackStatusDelete.');
            }
            // verify required parameter 'environmentId' is not null or undefined
            if (environmentId === null || environmentId === undefined) {
                throw new RequiredError('environmentId','Required parameter environmentId was null or undefined when calling edgeStackStatusDelete.');
            }
            const localVarPath = `/edge_stacks/{id}/status/{environmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackStatusUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeStackStatusUpdate.');
            }
            const localVarPath = `/edge_stacks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgestacksUpdateStatusPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling edgeStackUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edgeStackUpdate.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgestacksUpdateEdgeStackPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId','Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeStacksApi - functional programming interface
 * @export
 */
export const EdgeStacksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method: 'file' | 'string' | 'repository', body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackCreate(method, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name: string, file: any, edgeGroups: string, deploymentType: number, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, dryrun?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(method: 'file' | 'string' | 'repository', body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackCreateRepository(method, body, dryrun, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackCreateString(body, dryrun, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgestacksStackFileResponse> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerEdgeStack>> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id: number, environmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackStatusDelete(id, environmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackStatusUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEdgeStack> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).edgeStackUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeStackPayload> {
            const localVarFetchArgs = EdgeStacksApiFetchParamCreator(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeStacksApi - factory interface
 * @export
 */
export const EdgeStacksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method: 'file' | 'string' | 'repository', body: any, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackCreate(method, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name: string, file: any, edgeGroups: string, deploymentType: number, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, dryrun?: string, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(method: 'file' | 'string' | 'repository', body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackCreateRepository(method, body, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackCreateString(body, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id: number, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id: number, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackFile(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id: number, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackList(options)(fetch, basePath);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id: number, environmentId: number, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackStatusDelete(id, environmentId, options)(fetch, basePath);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackStatusUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: any) {
            return EdgeStacksApiFp(configuration).edgeStackUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
            return EdgeStacksApiFp(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};

/**
 * EdgeStacksApi - object-oriented interface
 * @export
 * @class EdgeStacksApi
 * @extends {BaseAPI}
 */
export class EdgeStacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack
     * @param {'file' | 'string' | 'repository'} method Creation Method
     * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreate(method: 'file' | 'string' | 'repository', body: any, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreate(method, body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from file
     * @param {string} name Name of the stack
     * @param {any} file Content of the Stack file
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
     * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
     * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
     * @param {boolean} [prePullImage] Pre Pull image
     * @param {boolean} [retryDeploy] Retry deploy
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateFile(name: string, file: any, edgeGroups: string, deploymentType: number, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, dryrun?: string, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a git repository
     * @param {'file' | 'string' | 'repository'} method Creation Method
     * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateRepository(method: 'file' | 'string' | 'repository', body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateRepository(method, body, dryrun, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a text
     * @param {EdgestacksEdgeStackFromStringPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateString(body, dryrun, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackDelete(id: number, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetches the stack file for an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackFile(id: number, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackInspect(id: number, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Fetches the list of EdgeStacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackList(options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackList(options)(this.fetch, this.basePath);
    }

    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Delete an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {number} environmentId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackStatusDelete(id: number, environmentId: number, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackStatusDelete(id, environmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Update an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackStatusUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Update an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: any) {
        return EdgeStacksApiFp(this.configuration).edgeStackUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
        return EdgeStacksApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeTemplatesApi - fetch parameter creator
 * @export
 */
export const EdgeTemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options: any = {}): FetchArgs {
            const localVarPath = `/edge_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeTemplatesApi - functional programming interface
 * @export
 */
export const EdgeTemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerTemplate>> {
            const localVarFetchArgs = EdgeTemplatesApiFetchParamCreator(configuration).edgeTemplateList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeTemplatesApi - factory interface
 * @export
 */
export const EdgeTemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options?: any) {
            return EdgeTemplatesApiFp(configuration).edgeTemplateList(options)(fetch, basePath);
        },
    };
};

/**
 * EdgeTemplatesApi - object-oriented interface
 * @export
 * @class EdgeTemplatesApi
 * @extends {BaseAPI}
 */
export class EdgeTemplatesApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Fetches the list of Edge Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeTemplatesApi
     */
    public edgeTemplateList(options?: any) {
        return EdgeTemplatesApiFp(this.configuration).edgeTemplateList(options)(this.fetch, this.basePath);
    }

}

/**
 * EndpointGroupsApi - fetch parameter creator
 * @export
 */
export const EndpointGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id: number, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointGroupAddEndpoint.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling endpointGroupAddEndpoint.');
            }
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointGroupDelete.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id: number, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointGroupDeleteEndpoint.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling endpointGroupDeleteEndpoint.');
            }
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options: any = {}): FetchArgs {
            const localVarPath = `/endpoint_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointGroupUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointGroupUpdate.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointgroupsEndpointGroupUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointGroupsIdGet.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointGroupsPost.');
            }
            const localVarPath = `/endpoint_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointgroupsEndpointGroupCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointGroupsApi - functional programming interface
 * @export
 */
export const EndpointGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id: number, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupAddEndpoint(id, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupDeleteEndpoint(id, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerEndpointGroup>> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpointGroup> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpointGroup> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupsIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpointGroup> {
            const localVarFetchArgs = EndpointGroupsApiFetchParamCreator(configuration).endpointGroupsPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EndpointGroupsApi - factory interface
 * @export
 */
export const EndpointGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id: number, endpointId: number, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupAddEndpoint(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id: number, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupDeleteEndpoint(id, endpointId, options)(fetch, basePath);
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupList(options)(fetch, basePath);
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id: number, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: any) {
            return EndpointGroupsApiFp(configuration).endpointGroupsPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * EndpointGroupsApi - object-oriented interface
 * @export
 * @class EndpointGroupsApi
 * @extends {BaseAPI}
 */
export class EndpointGroupsApi extends BaseAPI {
    /**
     * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
     * @summary Add an environment(endpoint) to an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupAddEndpoint(id: number, endpointId: number, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupAddEndpoint(id, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an environment(endpoint) group. **Access policy**: administrator
     * @summary Remove an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupDelete(id: number, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: administrator
     * @summary Removes environment(endpoint) from an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupDeleteEndpoint(id, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
     * @summary List Environment(Endpoint) groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupList(options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupList(options)(this.fetch, this.basePath);
    }

    /**
     * Update an environment(endpoint) group. **Access policy**: administrator
     * @summary Update an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
     * @summary Inspect an Environment(Endpoint) group
     * @param {number} id Environment(Endpoint) group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupsIdGet(id: number, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new environment(endpoint) group. **Access policy**: administrator
     * @summary Create an Environment(Endpoint) Group
     * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: any) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupsPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * EndpointsApi - fetch parameter creator
 * @export
 */
export const EndpointsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointAssociationDelete.');
            }
            const localVarPath = `/endpoints/{id}/association`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, URL?: string, publicURL?: string, groupID?: number, TLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: any, tLSCertFile?: any, tLSKeyFile?: any, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling endpointCreate.');
            }
            // verify required parameter 'endpointCreationType' is not null or undefined
            if (endpointCreationType === null || endpointCreationType === undefined) {
                throw new RequiredError('endpointCreationType','Required parameter endpointCreationType was null or undefined when calling endpointCreate.');
            }
            // verify required parameter 'edgeTunnelServerAddress' is not null or undefined
            if (edgeTunnelServerAddress === null || edgeTunnelServerAddress === undefined) {
                throw new RequiredError('edgeTunnelServerAddress','Required parameter edgeTunnelServerAddress was null or undefined when calling endpointCreate.');
            }
            const localVarPath = `/endpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (endpointCreationType !== undefined) {
                localVarFormParams.set('EndpointCreationType', endpointCreationType as any);
            }

            if (URL !== undefined) {
                localVarFormParams.set('URL', URL as any);
            }

            if (publicURL !== undefined) {
                localVarFormParams.set('PublicURL', publicURL as any);
            }

            if (groupID !== undefined) {
                localVarFormParams.set('GroupID', groupID as any);
            }

            if (TLS !== undefined) {
                localVarFormParams.set('TLS', TLS as any);
            }

            if (tLSSkipVerify !== undefined) {
                localVarFormParams.set('TLSSkipVerify', tLSSkipVerify as any);
            }

            if (tLSSkipClientVerify !== undefined) {
                localVarFormParams.set('TLSSkipClientVerify', tLSSkipClientVerify as any);
            }

            if (tLSCACertFile !== undefined) {
                localVarFormParams.set('TLSCACertFile', tLSCACertFile as any);
            }

            if (tLSCertFile !== undefined) {
                localVarFormParams.set('TLSCertFile', tLSCertFile as any);
            }

            if (tLSKeyFile !== undefined) {
                localVarFormParams.set('TLSKeyFile', tLSKeyFile as any);
            }

            if (azureApplicationID !== undefined) {
                localVarFormParams.set('AzureApplicationID', azureApplicationID as any);
            }

            if (azureTenantID !== undefined) {
                localVarFormParams.set('AzureTenantID', azureTenantID as any);
            }

            if (azureAuthenticationKey !== undefined) {
                localVarFormParams.set('AzureAuthenticationKey', azureAuthenticationKey as any);
            }

            if (tagIds) {
                tagIds.forEach((element) => {
                    localVarFormParams.append('TagIds', element as any);
                })
            }

            if (edgeCheckinInterval !== undefined) {
                localVarFormParams.set('EdgeCheckinInterval', edgeCheckinInterval as any);
            }

            if (edgeTunnelServerAddress !== undefined) {
                localVarFormParams.set('EdgeTunnelServerAddress', edgeTunnelServerAddress as any);
            }

            if (gpus !== undefined) {
                localVarFormParams.set('Gpus', gpus as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options: any = {}): FetchArgs {
            const localVarPath = `/endpoints/global-key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointDelete.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id: number, registryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointDockerhubStatus.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling endpointDockerhubStatus.');
            }
            const localVarPath = `/endpoints/{id}/dockerhub/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointEdgeStatusInspect.');
            }
            const localVarPath = `/endpoints/{id}/edge/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointInspect.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [sort] Sort results by this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start?: number, limit?: number, sort?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options: any = {}): FetchArgs {
            const localVarPath = `/endpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (groupIds) {
                localVarQueryParameter['groupIds'] = groupIds;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (tagsPartialMatch !== undefined) {
                localVarQueryParameter['tagsPartialMatch'] = tagsPartialMatch;
            }

            if (endpointIds) {
                localVarQueryParameter['endpointIds'] = endpointIds;
            }

            if (provisioned !== undefined) {
                localVarQueryParameter['provisioned'] = provisioned;
            }

            if (agentVersions) {
                localVarQueryParameter['agentVersions'] = agentVersions;
            }

            if (edgeAsync !== undefined) {
                localVarQueryParameter['edgeAsync'] = edgeAsync;
            }

            if (edgeDeviceUntrusted !== undefined) {
                localVarQueryParameter['edgeDeviceUntrusted'] = edgeDeviceUntrusted;
            }

            if (edgeCheckInPassedSeconds !== undefined) {
                localVarQueryParameter['edgeCheckInPassedSeconds'] = edgeCheckInPassedSeconds;
            }

            if (excludeSnapshots !== undefined) {
                localVarQueryParameter['excludeSnapshots'] = excludeSnapshots;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (edgeStackStatus !== undefined) {
                localVarQueryParameter['edgeStackStatus'] = edgeStackStatus;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id: number, namespace?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointRegistriesList.');
            }
            const localVarPath = `/endpoints/{id}/registries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointRegistryAccess.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling endpointRegistryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointRegistryAccess.');
            }
            const localVarPath = `/endpoints/{id}/registries/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointsRegistryAccessPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointSettingsUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointSettingsUpdate.');
            }
            const localVarPath = `/endpoints/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointsEndpointSettingsUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointSnapshot.');
            }
            const localVarPath = `/endpoints/{id}/snapshot`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options: any = {}): FetchArgs {
            const localVarPath = `/endpoints/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointUpdate.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointsEndpointUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling endpointUpdateRelations.');
            }
            const localVarPath = `/endpoints/relations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EndpointsEndpointUpdateRelationsPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: any, volumeID?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            const localVarPath = `/endpoints/{id}/docker/v2/browse/put`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (volumeID !== undefined) {
                localVarQueryParameter['volumeID'] = volumeID;
            }

            if (path !== undefined) {
                localVarFormParams.set('Path', path as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            // verify required parameter 'jobID' is not null or undefined
            if (jobID === null || jobID === undefined) {
                throw new RequiredError('jobID','Required parameter jobID was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId','Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointsApi - functional programming interface
 * @export
 */
export const EndpointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointAssociationDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, URL?: string, publicURL?: string, groupID?: number, TLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: any, tLSCertFile?: any, tLSKeyFile?: any, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpoint> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EndpointsEndpointCreateGlobalKeyResponse> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointCreateGlobalKey(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id: number, registryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EndpointsDockerhubStatusResponse> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointDockerhubStatus(id, registryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EndpointedgeEndpointEdgeStatusInspectResponse> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointEdgeStatusInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpoint> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [sort] Sort results by this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start?: number, limit?: number, sort?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerEndpoint>> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointList(start, limit, sort, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id: number, namespace?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerRegistry>> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointRegistriesList(id, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointRegistryAccess(id, registryId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpoint> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointSettingsUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointSnapshot(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointSnapshots(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerEndpoint> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointUpdateRelations(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: any, volumeID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeStackPayload> {
            const localVarFetchArgs = EndpointsApiFetchParamCreator(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EndpointsApi - factory interface
 * @export
 */
export const EndpointsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id: number, options?: any) {
            return EndpointsApiFp(configuration).endpointAssociationDelete(id, options)(fetch, basePath);
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, URL?: string, publicURL?: string, groupID?: number, TLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: any, tLSCertFile?: any, tLSKeyFile?: any, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: any) {
            return EndpointsApiFp(configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options?: any) {
            return EndpointsApiFp(configuration).endpointCreateGlobalKey(options)(fetch, basePath);
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id: number, options?: any) {
            return EndpointsApiFp(configuration).endpointDelete(id, options)(fetch, basePath);
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id: number, registryId: number, options?: any) {
            return EndpointsApiFp(configuration).endpointDockerhubStatus(id, registryId, options)(fetch, basePath);
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id: number, options?: any) {
            return EndpointsApiFp(configuration).endpointEdgeStatusInspect(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id: number, options?: any) {
            return EndpointsApiFp(configuration).endpointInspect(id, options)(fetch, basePath);
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [sort] Sort results by this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start?: number, limit?: number, sort?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: any) {
            return EndpointsApiFp(configuration).endpointList(start, limit, sort, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options)(fetch, basePath);
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id: number, namespace?: string, options?: any) {
            return EndpointsApiFp(configuration).endpointRegistriesList(id, namespace, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: any) {
            return EndpointsApiFp(configuration).endpointRegistryAccess(id, registryId, body, options)(fetch, basePath);
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: any) {
            return EndpointsApiFp(configuration).endpointSettingsUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id: number, options?: any) {
            return EndpointsApiFp(configuration).endpointSnapshot(id, options)(fetch, basePath);
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options?: any) {
            return EndpointsApiFp(configuration).endpointSnapshots(options)(fetch, basePath);
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: any) {
            return EndpointsApiFp(configuration).endpointUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: any) {
            return EndpointsApiFp(configuration).endpointUpdateRelations(body, options)(fetch, basePath);
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: any, volumeID?: string, options?: any) {
            return EndpointsApiFp(configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any) {
            return EndpointsApiFp(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
            return EndpointsApiFp(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};

/**
 * EndpointsApi - object-oriented interface
 * @export
 * @class EndpointsApi
 * @extends {BaseAPI}
 */
export class EndpointsApi extends BaseAPI {
    /**
     * De-association an edge environment(endpoint). **Access policy**: administrator
     * @summary De-association an edge environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointAssociationDelete(id: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointAssociationDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
     * @summary Create a new environment(endpoint)
     * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
     * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
     * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
     * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
     * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
     * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
     * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {any} [tLSCACertFile] TLS CA certificate file
     * @param {any} [tLSCertFile] TLS client certificate file
     * @param {any} [tLSKeyFile] TLS client key file
     * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
     * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
     * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
     * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, URL?: string, publicURL?: string, groupID?: number, TLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: any, tLSCertFile?: any, tLSKeyFile?: any, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: any) {
        return EndpointsApiFp(this.configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create or retrieve the endpoint for an EdgeID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointCreateGlobalKey(options?: any) {
        return EndpointsApiFp(this.configuration).endpointCreateGlobalKey(options)(this.fetch, this.basePath);
    }

    /**
     * Remove an environment(endpoint). **Access policy**: administrator
     * @summary Remove an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointDelete(id: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * get docker pull limits for a docker hub registry in the environment **Access policy**:
     * @summary fetch docker pull limits
     * @param {number} id endpoint ID
     * @param {number} registryId registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointDockerhubStatus(id: number, registryId: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointDockerhubStatus(id, registryId, options)(this.fetch, this.basePath);
    }

    /**
     * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
     * @summary Get environment(endpoint) status
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointEdgeStatusInspect(id: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointEdgeStatusInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about an environment(endpoint). **Access policy**: restricted
     * @summary Inspect an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointInspect(id: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
     * @summary List environments(endpoints)
     * @param {number} [start] Start searching from
     * @param {number} [limit] Limit results to this value
     * @param {number} [sort] Sort results by this value
     * @param {number} [order] Order sorted results by desc/asc
     * @param {string} [search] Search query
     * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
     * @param {Array<number>} [status] List environments(endpoints) by this status
     * @param {Array<number>} [types] List environments(endpoints) of this type
     * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
     * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
     * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
     * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
     * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
     * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
     * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
     * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
     * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
     * @param {string} [name] will return only environments(endpoints) with this name
     * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointList(start?: number, limit?: number, sort?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: any) {
        return EndpointsApiFp(this.configuration).endpointList(start, limit, sort, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options)(this.fetch, this.basePath);
    }

    /**
     * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
     * @summary List Registries on environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointRegistriesList(id: number, namespace?: string, options?: any) {
        return EndpointsApiFp(this.configuration).endpointRegistriesList(id, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary update registry access for environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {number} registryId Registry identifier
     * @param {EndpointsRegistryAccessPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: any) {
        return EndpointsApiFp(this.configuration).endpointRegistryAccess(id, registryId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update settings for an environment(endpoint). **Access policy**: authenticated
     * @summary Update settings for an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: any) {
        return EndpointsApiFp(this.configuration).endpointSettingsUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Snapshots an environment(endpoint) **Access policy**: administrator
     * @summary Snapshots an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSnapshot(id: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointSnapshot(id, options)(this.fetch, this.basePath);
    }

    /**
     * Snapshot all environments(endpoints) **Access policy**: administrator
     * @summary Snapshot all environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSnapshots(options?: any) {
        return EndpointsApiFp(this.configuration).endpointSnapshots(options)(this.fetch, this.basePath);
    }

    /**
     * Update an environment(endpoint). **Access policy**: authenticated
     * @summary Update an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: any) {
        return EndpointsApiFp(this.configuration).endpointUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
     * @summary Update relations for a list of environments
     * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: any) {
        return EndpointsApiFp(this.configuration).endpointUpdateRelations(body, options)(this.fetch, this.basePath);
    }

    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload a file under a specific path on the file system of an environment (endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} path The destination path to upload the file to
     * @param {any} file The file to upload
     * @param {string} [volumeID] Optional volume identifier to upload the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: any, volumeID?: string, options?: any) {
        return EndpointsApiFp(this.configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any) {
        return EndpointsApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }

}

/**
 * GitopsApi - fetch parameter creator
 * @export
 */
export const GitopsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling gitOperationRepoFilePreview.');
            }
            const localVarPath = `/gitops/repo/file/preview`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GitopsRepositoryFilePreviewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitopsApi - functional programming interface
 * @export
 */
export const GitopsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GitopsFileResponse> {
            const localVarFetchArgs = GitopsApiFetchParamCreator(configuration).gitOperationRepoFilePreview(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GitopsApi - factory interface
 * @export
 */
export const GitopsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: any) {
            return GitopsApiFp(configuration).gitOperationRepoFilePreview(body, options)(fetch, basePath);
        },
    };
};

/**
 * GitopsApi - object-oriented interface
 * @export
 * @class GitopsApi
 * @extends {BaseAPI}
 */
export class GitopsApi extends BaseAPI {
    /**
     * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
     * @summary preview the content of target file in the git repository
     * @param {GitopsRepositoryFilePreviewPayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitopsApi
     */
    public gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: any) {
        return GitopsApiFp(this.configuration).gitOperationRepoFilePreview(body, options)(this.fetch, this.basePath);
    }

}

/**
 * HelmApi - fetch parameter creator
 * @export
 */
export const HelmApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id: number, release: string, namespace?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling helmDelete.');
            }
            // verify required parameter 'release' is not null or undefined
            if (release === null || release === undefined) {
                throw new RequiredError('release','Required parameter release was null or undefined when calling helmDelete.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/{release}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"release"}}`, encodeURIComponent(String(release)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id: number, payload: HelmInstallChartPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling helmInstall.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling helmInstall.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HelmInstallChartPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id: number, namespace?: string, filter?: string, selector?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling helmList.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (selector !== undefined) {
                localVarQueryParameter['selector'] = selector;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo: string, options: any = {}): FetchArgs {
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling helmRepoSearch.');
            }
            const localVarPath = `/templates/helm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo: string, chart: string, command: string, options: any = {}): FetchArgs {
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo','Required parameter repo was null or undefined when calling helmShow.');
            }
            // verify required parameter 'chart' is not null or undefined
            if (chart === null || chart === undefined) {
                throw new RequiredError('chart','Required parameter chart was null or undefined when calling helmShow.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling helmShow.');
            }
            const localVarPath = `/templates/helm/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling helmUserRepositoriesList.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id: number, payload: HelmAddHelmRepoUrlPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling helmUserRepositoryCreate.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling helmUserRepositoryCreate.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HelmAddHelmRepoUrlPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmApi - functional programming interface
 * @export
 */
export const HelmApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id: number, release: string, namespace?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmDelete(id, release, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id: number, payload: HelmInstallChartPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReleaseRelease> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmInstall(id, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ReleaseReleaseElement>> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmList(id, namespace, filter, selector, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmRepoSearch(repo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo: string, chart: string, command: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmShow(repo, chart, command, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelmHelmUserRepositoryResponse> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmUserRepositoriesList(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id: number, payload: HelmAddHelmRepoUrlPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerHelmUserRepository> {
            const localVarFetchArgs = HelmApiFetchParamCreator(configuration).helmUserRepositoryCreate(id, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HelmApi - factory interface
 * @export
 */
export const HelmApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id: number, release: string, namespace?: string, options?: any) {
            return HelmApiFp(configuration).helmDelete(id, release, namespace, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id: number, payload: HelmInstallChartPayload, options?: any) {
            return HelmApiFp(configuration).helmInstall(id, payload, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: any) {
            return HelmApiFp(configuration).helmList(id, namespace, filter, selector, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo: string, options?: any) {
            return HelmApiFp(configuration).helmRepoSearch(repo, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo: string, chart: string, command: string, options?: any) {
            return HelmApiFp(configuration).helmShow(repo, chart, command, options)(fetch, basePath);
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id: number, options?: any) {
            return HelmApiFp(configuration).helmUserRepositoriesList(id, options)(fetch, basePath);
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id: number, payload: HelmAddHelmRepoUrlPayload, options?: any) {
            return HelmApiFp(configuration).helmUserRepositoryCreate(id, payload, options)(fetch, basePath);
        },
    };
};

/**
 * HelmApi - object-oriented interface
 * @export
 * @class HelmApi
 * @extends {BaseAPI}
 */
export class HelmApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Delete Helm Release
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} release The name of the release/application to uninstall
     * @param {string} [namespace] An optional namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmDelete(id: number, release: string, namespace?: string, options?: any) {
        return HelmApiFp(this.configuration).helmDelete(id, release, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Install Helm Chart
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmInstallChartPayload} payload Chart details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmInstall(id: number, payload: HelmInstallChartPayload, options?: any) {
        return HelmApiFp(this.configuration).helmInstall(id, payload, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary List Helm Releases
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] specify an optional namespace
     * @param {string} [filter] specify an optional filter
     * @param {string} [selector] specify an optional selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: any) {
        return HelmApiFp(this.configuration).helmList(id, namespace, filter, selector, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Search Helm Charts
     * @param {string} repo Helm repository URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmRepoSearch(repo: string, options?: any) {
        return HelmApiFp(this.configuration).helmRepoSearch(repo, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Show Helm Chart Information
     * @param {string} repo Helm repository URL
     * @param {string} chart Chart name
     * @param {string} command chart/values/readme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmShow(repo: string, chart: string, command: string, options?: any) {
        return HelmApiFp(this.configuration).helmShow(repo, chart, command, options)(this.fetch, this.basePath);
    }

    /**
     * Inspect a user helm repositories. **Access policy**: authenticated
     * @summary List a users helm repositories
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoriesList(id: number, options?: any) {
        return HelmApiFp(this.configuration).helmUserRepositoriesList(id, options)(this.fetch, this.basePath);
    }

    /**
     * Create a user helm repository. **Access policy**: authenticated
     * @summary Create a user helm repository
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoryCreate(id: number, payload: HelmAddHelmRepoUrlPayload, options?: any) {
        return HelmApiFp(this.configuration).helmUserRepositoryCreate(id, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * IntelApi - fetch parameter creator
 * @export
 */
export const IntelApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options: any = {}): FetchArgs {
            const localVarPath = `/fdo/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProfile.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceAction.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deviceAction.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deviceAction.');
            }
            const localVarPath = `/open_amt/{id}/devices/{deviceId}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OpenamtDeviceActionPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceFeatures.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deviceFeatures.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deviceFeatures.');
            }
            const localVarPath = `/open_amt/{id}/devices_features/{deviceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OpenamtDeviceFeaturesPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling duplicate.');
            }
            const localVarPath = `/fdo/profiles/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body: FdoFdoConfigurePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling fdoConfigure.');
            }
            const localVarPath = `/fdo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FdoFdoConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options: any = {}): FetchArgs {
            // verify required parameter 'guid' is not null or undefined
            if (guid === null || guid === undefined) {
                throw new RequiredError('guid','Required parameter guid was null or undefined when calling fdoConfigureDevice.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling fdoConfigureDevice.');
            }
            const localVarPath = `/fdo/configure/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FdoDeviceConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options: any = {}): FetchArgs {
            const localVarPath = `/fdo/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling fdoProfileInspect.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options: any = {}): FetchArgs {
            const localVarPath = `/fdo/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options: any = {}): FetchArgs {
            const localVarPath = `/fdo/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling openAMTActivate.');
            }
            const localVarPath = `/open_amt/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling openAMTConfigure.');
            }
            const localVarPath = `/open_amt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OpenamtOpenAMTConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling openAMTDevices.');
            }
            const localVarPath = `/open_amt/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling openAMTHostInfo.');
            }
            const localVarPath = `/open_amt/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntelApi - functional programming interface
 * @export
 */
export const IntelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).createProfile(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).deleteProfile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).deviceAction(id, deviceId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).deviceFeatures(id, deviceId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).duplicate(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body: FdoFdoConfigurePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoConfigure(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoConfigureDevice(guid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoListAll(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoProfileInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoProfileList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).fdoRegisterDevice(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).openAMTActivate(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).openAMTConfigure(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).openAMTDevices(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).openAMTHostInfo(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntelApiFetchParamCreator(configuration).updateProfile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntelApi - factory interface
 * @export
 */
export const IntelApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options?: any) {
            return IntelApiFp(configuration).createProfile(options)(fetch, basePath);
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: number, options?: any) {
            return IntelApiFp(configuration).deleteProfile(id, options)(fetch, basePath);
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: any) {
            return IntelApiFp(configuration).deviceAction(id, deviceId, body, options)(fetch, basePath);
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: any) {
            return IntelApiFp(configuration).deviceFeatures(id, deviceId, body, options)(fetch, basePath);
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id: number, options?: any) {
            return IntelApiFp(configuration).duplicate(id, options)(fetch, basePath);
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body: FdoFdoConfigurePayload, options?: any) {
            return IntelApiFp(configuration).fdoConfigure(body, options)(fetch, basePath);
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: any) {
            return IntelApiFp(configuration).fdoConfigureDevice(guid, body, options)(fetch, basePath);
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options?: any) {
            return IntelApiFp(configuration).fdoListAll(options)(fetch, basePath);
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id: number, options?: any) {
            return IntelApiFp(configuration).fdoProfileInspect(id, options)(fetch, basePath);
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options?: any) {
            return IntelApiFp(configuration).fdoProfileList(options)(fetch, basePath);
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options?: any) {
            return IntelApiFp(configuration).fdoRegisterDevice(options)(fetch, basePath);
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id: number, options?: any) {
            return IntelApiFp(configuration).openAMTActivate(id, options)(fetch, basePath);
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: any) {
            return IntelApiFp(configuration).openAMTConfigure(body, options)(fetch, basePath);
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id: number, options?: any) {
            return IntelApiFp(configuration).openAMTDevices(id, options)(fetch, basePath);
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id: number, options?: any) {
            return IntelApiFp(configuration).openAMTHostInfo(id, options)(fetch, basePath);
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id: number, options?: any) {
            return IntelApiFp(configuration).updateProfile(id, options)(fetch, basePath);
        },
    };
};

/**
 * IntelApi - object-oriented interface
 * @export
 * @class IntelApi
 * @extends {BaseAPI}
 */
export class IntelApi extends BaseAPI {
    /**
     * creates a new FDO Profile **Access policy**: administrator
     * @summary creates a new FDO Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public createProfile(options?: any) {
        return IntelApiFp(this.configuration).createProfile(options)(this.fetch, this.basePath);
    }

    /**
     * deletes a FDO Profile **Access policy**: administrator
     * @summary deletes a FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deleteProfile(id: number, options?: any) {
        return IntelApiFp(this.configuration).deleteProfile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Execute out of band action on an AMT managed device **Access policy**: administrator
     * @summary Execute out of band action on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceActionPayload} body Device Action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: any) {
        return IntelApiFp(this.configuration).deviceAction(id, deviceId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Enable features on an AMT managed device **Access policy**: administrator
     * @summary Enable features on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceFeaturesPayload} body Device Features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: any) {
        return IntelApiFp(this.configuration).deviceFeatures(id, deviceId, body, options)(this.fetch, this.basePath);
    }

    /**
     * duplicated an existing FDO Profile **Access policy**: administrator
     * @summary duplicated an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public duplicate(id: number, options?: any) {
        return IntelApiFp(this.configuration).duplicate(id, options)(this.fetch, this.basePath);
    }

    /**
     * Enable Portainer's FDO capabilities **Access policy**: administrator
     * @summary Enable Portainer's FDO capabilities
     * @param {FdoFdoConfigurePayload} body FDO Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoConfigure(body: FdoFdoConfigurePayload, options?: any) {
        return IntelApiFp(this.configuration).fdoConfigure(body, options)(this.fetch, this.basePath);
    }

    /**
     * configures an FDO device **Access policy**: administrator
     * @summary configures an FDO device
     * @param {number} guid Guid
     * @param {FdoDeviceConfigurePayload} body Device Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: any) {
        return IntelApiFp(this.configuration).fdoConfigureDevice(guid, body, options)(this.fetch, this.basePath);
    }

    /**
     * List all known FDO vouchers **Access policy**: administrator
     * @summary List all known FDO vouchers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoListAll(options?: any) {
        return IntelApiFp(this.configuration).fdoListAll(options)(this.fetch, this.basePath);
    }

    /**
     * retrieves a given FDO profile information and content **Access policy**: administrator
     * @summary retrieves a given FDO profile information and content
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoProfileInspect(id: number, options?: any) {
        return IntelApiFp(this.configuration).fdoProfileInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * retrieves all FDO profiles **Access policy**: administrator
     * @summary retrieves all FDO profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoProfileList(options?: any) {
        return IntelApiFp(this.configuration).fdoProfileList(options)(this.fetch, this.basePath);
    }

    /**
     * register an FDO device **Access policy**: administrator
     * @summary register an FDO device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoRegisterDevice(options?: any) {
        return IntelApiFp(this.configuration).fdoRegisterDevice(options)(this.fetch, this.basePath);
    }

    /**
     * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
     * @summary Activate OpenAMT device and associate to agent endpoint
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTActivate(id: number, options?: any) {
        return IntelApiFp(this.configuration).openAMTActivate(id, options)(this.fetch, this.basePath);
    }

    /**
     * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
     * @summary Enable Portainer's OpenAMT capabilities
     * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: any) {
        return IntelApiFp(this.configuration).openAMTConfigure(body, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
     * @summary Fetch OpenAMT managed devices information for endpoint
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTDevices(id: number, options?: any) {
        return IntelApiFp(this.configuration).openAMTDevices(id, options)(this.fetch, this.basePath);
    }

    /**
     * Request OpenAMT info from a node **Access policy**: administrator
     * @summary Request OpenAMT info from a node
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTHostInfo(id: number, options?: any) {
        return IntelApiFp(this.configuration).openAMTHostInfo(id, options)(this.fetch, this.basePath);
    }

    /**
     * updates an existing FDO Profile **Access policy**: administrator
     * @summary updates an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public updateProfile(id: number, options?: any) {
        return IntelApiFp(this.configuration).updateProfile(id, options)(this.fetch, this.basePath);
    }

}

/**
 * KubernetesApi - fetch parameter creator
 * @export
 */
export const KubernetesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createKubernetesIngress.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createKubernetesIngress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createKubernetesIngress.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sIngressInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createKubernetesNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sNamespaceDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createKubernetesService.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createKubernetesService.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createKubernetesService.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sServiceInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id: number, body: KubernetesK8sIngressDeleteRequests, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteKubernetesIngresses.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteKubernetesIngresses.');
            }
            const localVarPath = `/kubernetes/{id}/ingresses/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sIngressDeleteRequests" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id: number, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id: number, body: KubernetesK8sServiceDeleteRequests, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteKubernetesServices.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteKubernetesServices.');
            }
            const localVarPath = `/kubernetes/{id}/services/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sServiceDeleteRequests" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options: any = {}): FetchArgs {
            const localVarPath = `/kubernetes/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (excludeIds) {
                localVarQueryParameter['excludeIds'] = excludeIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesIngressControllers.');
            }
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowedOnly'] = allowedOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id: number, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesIngressControllersByNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesIngresses.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesIngresses.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getKubernetesIngresses.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;KubernetesK8sIngressInfo&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesMetricsForAllNodes.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id: number, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesMetricsForAllPods.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesMetricsForAllPods.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id: number, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesMetricsForNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getKubernetesMetricsForNode.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/nodes/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id: number, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesMetricsForPod.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesMetricsForPod.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getKubernetesMetricsForPod.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id: number, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesNamespaces.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesNodesLimits.');
            }
            const localVarPath = `/kubernetes/{id}/nodes_limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKubernetesServices.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getKubernetesServices.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (lookupapplications !== undefined) {
                localVarQueryParameter['lookupapplications'] = lookupapplications;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/system`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesNamespacesToggleSystemPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateKubernetesIngress.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateKubernetesIngress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateKubernetesIngress.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sIngressInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateKubernetesIngressControllers.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateKubernetesIngressControllers.');
            }
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Array&lt;KubernetesK8sIngressController&gt;&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Array&lt;KubernetesK8sIngressController&gt;&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateKubernetesNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sNamespaceDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateKubernetesService.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateKubernetesService.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateKubernetesService.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KubernetesK8sServiceInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KubernetesApi - functional programming interface
 * @export
 */
export const KubernetesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).createKubernetesIngress(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).createKubernetesNamespace(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).createKubernetesService(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id: number, body: KubernetesK8sIngressDeleteRequests, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).deleteKubernetesIngresses(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id: number, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).deleteKubernetesNamespace(id, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id: number, body: KubernetesK8sServiceDeleteRequests, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).deleteKubernetesServices(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesConfig(ids, excludeIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<KubernetesK8sIngressController>> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesIngressControllers(id, allowedOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<KubernetesK8sIngressController>> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesIngressControllersByNamespace(id, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesIngresses(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1beta1NodeMetricsList> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesMetricsForAllNodes(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id: number, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1beta1PodMetricsList> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesMetricsForAllPods(id, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id: number, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1beta1NodeMetrics> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesMetricsForNode(id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1beta1PodMetrics> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesMetricsForPod(id, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id: number, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerK8sNamespaceInfo> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesNamespace(id, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: PortainerK8sNamespaceInfo; }> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesNamespaces(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerK8sNodesLimits> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesNodesLimits(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<KubernetesK8sServiceInfo>> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).getKubernetesServices(id, namespace, lookupapplications, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).updateKubernetesIngress(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).updateKubernetesIngressControllers(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).updateKubernetesNamespace(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KubernetesApiFetchParamCreator(configuration).updateKubernetesService(id, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KubernetesApi - factory interface
 * @export
 */
export const KubernetesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any) {
            return KubernetesApiFp(configuration).createKubernetesIngress(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any) {
            return KubernetesApiFp(configuration).createKubernetesNamespace(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any) {
            return KubernetesApiFp(configuration).createKubernetesService(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id: number, body: KubernetesK8sIngressDeleteRequests, options?: any) {
            return KubernetesApiFp(configuration).deleteKubernetesIngresses(id, body, options)(fetch, basePath);
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id: number, namespace: string, options?: any) {
            return KubernetesApiFp(configuration).deleteKubernetesNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id: number, body: KubernetesK8sServiceDeleteRequests, options?: any) {
            return KubernetesApiFp(configuration).deleteKubernetesServices(id, body, options)(fetch, basePath);
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesConfig(ids, excludeIds, options)(fetch, basePath);
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesIngressControllers(id, allowedOnly, options)(fetch, basePath);
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesIngressControllersByNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesIngresses(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id: number, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesMetricsForAllNodes(id, options)(fetch, basePath);
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id: number, namespace: string, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesMetricsForAllPods(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id: number, name: string, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesMetricsForNode(id, name, options)(fetch, basePath);
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesMetricsForPod(id, namespace, name, options)(fetch, basePath);
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id: number, namespace: string, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id: number, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesNamespaces(id, options)(fetch, basePath);
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id: number, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesNodesLimits(id, options)(fetch, basePath);
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: any) {
            return KubernetesApiFp(configuration).getKubernetesServices(id, namespace, lookupapplications, options)(fetch, basePath);
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: any) {
            return KubernetesApiFp(configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any) {
            return KubernetesApiFp(configuration).updateKubernetesIngress(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: any) {
            return KubernetesApiFp(configuration).updateKubernetesIngressControllers(id, body, options)(fetch, basePath);
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: any) {
            return KubernetesApiFp(configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any) {
            return KubernetesApiFp(configuration).updateKubernetesNamespace(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any) {
            return KubernetesApiFp(configuration).updateKubernetesService(id, namespace, body, options)(fetch, basePath);
        },
    };
};

/**
 * KubernetesApi - object-oriented interface
 * @export
 * @class KubernetesApi
 * @extends {BaseAPI}
 */
export class KubernetesApi extends BaseAPI {
    /**
     * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
     * @summary Create a kubernetes ingress by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any) {
        return KubernetesApiFp(this.configuration).createKubernetesIngress(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Create a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any) {
        return KubernetesApiFp(this.configuration).createKubernetesNamespace(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Create a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any) {
        return KubernetesApiFp(this.configuration).createKubernetesService(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
     * @summary Delete kubernetes ingresses
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesIngresses(id: number, body: KubernetesK8sIngressDeleteRequests, options?: any) {
        return KubernetesApiFp(this.configuration).deleteKubernetesIngresses(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Delete kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesNamespace(id: number, namespace: string, options?: any) {
        return KubernetesApiFp(this.configuration).deleteKubernetesNamespace(id, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Delete the provided list of kubernetes services **Access policy**: authenticated
     * @summary Delete kubernetes services
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesServices(id: number, body: KubernetesK8sServiceDeleteRequests, options?: any) {
        return KubernetesApiFp(this.configuration).deleteKubernetesServices(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
     * @summary Generate a kubeconfig file enabling client communication with k8s api server
     * @param {Array<number>} [ids] will include only these environments(endpoints)
     * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesConfig(ids, excludeIds, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of ingress controllers for the given environment **Access policy**: authenticated
     * @summary Get a list of ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {boolean} [allowedOnly] Only return allowed ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesIngressControllers(id, allowedOnly, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
     * @summary Get a list ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesIngressControllersByNamespace(id, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
     * @summary Get kubernetes ingresses by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesIngresses(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of nodes with their live metrics **Access policy**: authenticated
     * @summary Get a list of nodes with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForAllNodes(id: number, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForAllNodes(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of pods with their live metrics **Access policy**: authenticated
     * @summary Get a list of pods with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForAllPods(id: number, namespace: string, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForAllPods(id, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Get live metrics for a node **Access policy**: authenticated
     * @summary Get live metrics for a node
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} name Node identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForNode(id: number, name: string, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForNode(id, name, options)(this.fetch, this.basePath);
    }

    /**
     * Get live metrics for a pod **Access policy**: authenticated
     * @summary Get live metrics for a pod
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {string} name Pod identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForPod(id, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
     * @summary Get kubernetes namespace details
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNamespace(id: number, namespace: string, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesNamespace(id, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
     * @summary Get a list of kubernetes namespaces
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNamespaces(id: number, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesNamespaces(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
     * @summary Get CPU and memory limits of all nodes within k8s cluster
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNodesLimits(id: number, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesNodesLimits(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
     * @summary Get a list of kubernetes services for a given namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {boolean} [lookupapplications] Lookup applications associated with each service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: any) {
        return KubernetesApiFp(this.configuration).getKubernetesServices(id, namespace, lookupapplications, options)(this.fetch, this.basePath);
    }

    /**
     * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
     * @summary Toggle the system state for a namespace
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesNamespacesToggleSystemPayload} body Update details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: any) {
        return KubernetesApiFp(this.configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
     * @summary Update kubernetes ingress rule
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngress(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update (block/unblock) ingress controllers **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: any) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngressControllers(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: any) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Updates a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {KubernetesK8sNamespaceDetails} body Namespace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any) {
        return KubernetesApiFp(this.configuration).updateKubernetesNamespace(id, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Update a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any) {
        return KubernetesApiFp(this.configuration).updateKubernetesService(id, namespace, body, options)(this.fetch, this.basePath);
    }

}

/**
 * LdapApi - fetch parameter creator
 * @export
 */
export const LdapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body: LdapCheckPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling lDAPCheck.');
            }
            const localVarPath = `/ldap/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LdapCheckPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LdapApi - functional programming interface
 * @export
 */
export const LdapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body: LdapCheckPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LdapApiFetchParamCreator(configuration).lDAPCheck(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LdapApi - factory interface
 * @export
 */
export const LdapApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body: LdapCheckPayload, options?: any) {
            return LdapApiFp(configuration).lDAPCheck(body, options)(fetch, basePath);
        },
    };
};

/**
 * LdapApi - object-oriented interface
 * @export
 * @class LdapApi
 * @extends {BaseAPI}
 */
export class LdapApi extends BaseAPI {
    /**
     * Test LDAP connectivity using LDAP details **Access policy**: administrator
     * @summary Test LDAP connectivity
     * @param {LdapCheckPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdapApi
     */
    public lDAPCheck(body: LdapCheckPayload, options?: any) {
        return LdapApiFp(this.configuration).lDAPCheck(body, options)(this.fetch, this.basePath);
    }

}

/**
 * MotdApi - fetch parameter creator
 * @export
 */
export const MotdApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options: any = {}): FetchArgs {
            const localVarPath = `/motd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MotdApi - functional programming interface
 * @export
 */
export const MotdApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MotdMotdResponse> {
            const localVarFetchArgs = MotdApiFetchParamCreator(configuration).mOTD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MotdApi - factory interface
 * @export
 */
export const MotdApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options?: any) {
            return MotdApiFp(configuration).mOTD(options)(fetch, basePath);
        },
    };
};

/**
 * MotdApi - object-oriented interface
 * @export
 * @class MotdApi
 * @extends {BaseAPI}
 */
export class MotdApi extends BaseAPI {
    /**
     * **Access policy**: restricted
     * @summary fetches the message of the day
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotdApi
     */
    public mOTD(options?: any) {
        return MotdApiFp(this.configuration).mOTD(options)(this.fetch, this.basePath);
    }

}

/**
 * RbacEnabledApi - fetch parameter creator
 * @export
 */
export const RbacEnabledApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling isRBACEnabled.');
            }
            const localVarPath = `/kubernetes/{id}/rbac_enabled`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacEnabledApi - functional programming interface
 * @export
 */
export const RbacEnabledApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RbacEnabledApiFetchParamCreator(configuration).isRBACEnabled(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RbacEnabledApi - factory interface
 * @export
 */
export const RbacEnabledApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id: number, options?: any) {
            return RbacEnabledApiFp(configuration).isRBACEnabled(id, options)(fetch, basePath);
        },
    };
};

/**
 * RbacEnabledApi - object-oriented interface
 * @export
 * @class RbacEnabledApi
 * @extends {BaseAPI}
 */
export class RbacEnabledApi extends BaseAPI {
    /**
     * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
     * @summary Check if RBAC is enabled
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacEnabledApi
     */
    public isRBACEnabled(id: number, options?: any) {
        return RbacEnabledApiFp(this.configuration).isRBACEnabled(id, options)(this.fetch, this.basePath);
    }

}

/**
 * RegistriesApi - fetch parameter creator
 * @export
 */
export const RegistriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling registryConfigure.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registryConfigure.');
            }
            const localVarPath = `/registries/{id}/configure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistriesRegistryConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body: RegistriesRegistryCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registryCreate.');
            }
            const localVarPath = `/registries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistriesRegistryCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling registryDelete.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling registryInspect.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options: any = {}): FetchArgs {
            const localVarPath = `/registries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling registryUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registryUpdate.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistriesRegistryUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistriesApi - functional programming interface
 * @export
 */
export const RegistriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryConfigure(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body: RegistriesRegistryCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerRegistry> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerRegistry> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerRegistry>> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerRegistry> {
            const localVarFetchArgs = RegistriesApiFetchParamCreator(configuration).registryUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistriesApi - factory interface
 * @export
 */
export const RegistriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: any) {
            return RegistriesApiFp(configuration).registryConfigure(id, body, options)(fetch, basePath);
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body: RegistriesRegistryCreatePayload, options?: any) {
            return RegistriesApiFp(configuration).registryCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id: number, options?: any) {
            return RegistriesApiFp(configuration).registryDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id: number, options?: any) {
            return RegistriesApiFp(configuration).registryInspect(id, options)(fetch, basePath);
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options?: any) {
            return RegistriesApiFp(configuration).registryList(options)(fetch, basePath);
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: any) {
            return RegistriesApiFp(configuration).registryUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI {
    /**
     * Configures a registry. **Access policy**: restricted
     * @summary Configures a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryConfigurePayload} body Registry configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: any) {
        return RegistriesApiFp(this.configuration).registryConfigure(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new registry. **Access policy**: restricted
     * @summary Create a new registry
     * @param {RegistriesRegistryCreatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryCreate(body: RegistriesRegistryCreatePayload, options?: any) {
        return RegistriesApiFp(this.configuration).registryCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a registry **Access policy**: restricted
     * @summary Remove a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryDelete(id: number, options?: any) {
        return RegistriesApiFp(this.configuration).registryDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a registry. **Access policy**: restricted
     * @summary Inspect a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryInspect(id: number, options?: any) {
        return RegistriesApiFp(this.configuration).registryInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
     * @summary List Registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryList(options?: any) {
        return RegistriesApiFp(this.configuration).registryList(options)(this.fetch, this.basePath);
    }

    /**
     * Update a registry **Access policy**: restricted
     * @summary Update a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryUpdatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: any) {
        return RegistriesApiFp(this.configuration).registryUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ResourceControlsApi - fetch parameter creator
 * @export
 */
export const ResourceControlsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resourceControlCreate.');
            }
            const localVarPath = `/resource_controls`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourcecontrolsResourceControlCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resourceControlDelete.');
            }
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resourceControlUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resourceControlUpdate.');
            }
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourcecontrolsResourceControlUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceControlsApi - functional programming interface
 * @export
 */
export const ResourceControlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerResourceControl> {
            const localVarFetchArgs = ResourceControlsApiFetchParamCreator(configuration).resourceControlCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceControlsApiFetchParamCreator(configuration).resourceControlDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerResourceControl> {
            const localVarFetchArgs = ResourceControlsApiFetchParamCreator(configuration).resourceControlUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourceControlsApi - factory interface
 * @export
 */
export const ResourceControlsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: any) {
            return ResourceControlsApiFp(configuration).resourceControlCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id: number, options?: any) {
            return ResourceControlsApiFp(configuration).resourceControlDelete(id, options)(fetch, basePath);
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: any) {
            return ResourceControlsApiFp(configuration).resourceControlUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ResourceControlsApi - object-oriented interface
 * @export
 * @class ResourceControlsApi
 * @extends {BaseAPI}
 */
export class ResourceControlsApi extends BaseAPI {
    /**
     * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
     * @summary Create a new resource control
     * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: any) {
        return ResourceControlsApiFp(this.configuration).resourceControlCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a resource control. **Access policy**: administrator
     * @summary Remove a resource control
     * @param {number} id Resource control identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlDelete(id: number, options?: any) {
        return ResourceControlsApiFp(this.configuration).resourceControlDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Update a resource control **Access policy**: authenticated
     * @summary Update a resource control
     * @param {number} id Resource control identifier
     * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: any) {
        return ResourceControlsApiFp(this.configuration).resourceControlUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RolesApi - fetch parameter creator
 * @export
 */
export const RolesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options: any = {}): FetchArgs {
            const localVarPath = `/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerRole>> {
            const localVarFetchArgs = RolesApiFetchParamCreator(configuration).roleList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options?: any) {
            return RolesApiFp(configuration).roleList(options)(fetch, basePath);
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List all roles available for use **Access policy**: administrator
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public roleList(options?: any) {
        return RolesApiFp(this.configuration).roleList(options)(this.fetch, this.basePath);
    }

}

/**
 * SettingsApi - fetch parameter creator
 * @export
 */
export const SettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options: any = {}): FetchArgs {
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options: any = {}): FetchArgs {
            const localVarPath = `/settings/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body: SettingsSettingsUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling settingsUpdate.');
            }
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SettingsSettingsUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerSettings> {
            const localVarFetchArgs = SettingsApiFetchParamCreator(configuration).settingsInspect(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SettingsPublicSettingsResponse> {
            const localVarFetchArgs = SettingsApiFetchParamCreator(configuration).settingsPublic(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body: SettingsSettingsUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerSettings> {
            const localVarFetchArgs = SettingsApiFetchParamCreator(configuration).settingsUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options?: any) {
            return SettingsApiFp(configuration).settingsInspect(options)(fetch, basePath);
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options?: any) {
            return SettingsApiFp(configuration).settingsPublic(options)(fetch, basePath);
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body: SettingsSettingsUpdatePayload, options?: any) {
            return SettingsApiFp(configuration).settingsUpdate(body, options)(fetch, basePath);
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Retrieve Portainer settings. **Access policy**: administrator
     * @summary Retrieve Portainer settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsInspect(options?: any) {
        return SettingsApiFp(this.configuration).settingsInspect(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
     * @summary Retrieve Portainer public settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsPublic(options?: any) {
        return SettingsApiFp(this.configuration).settingsPublic(options)(this.fetch, this.basePath);
    }

    /**
     * Update Portainer settings. **Access policy**: administrator
     * @summary Update Portainer settings
     * @param {SettingsSettingsUpdatePayload} body New settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsUpdate(body: SettingsSettingsUpdatePayload, options?: any) {
        return SettingsApiFp(this.configuration).settingsUpdate(body, options)(this.fetch, this.basePath);
    }

}

/**
 * SslApi - fetch parameter creator
 * @export
 */
export const SslApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options: any = {}): FetchArgs {
            const localVarPath = `/ssl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body: SslSslUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sSLUpdate.');
            }
            const localVarPath = `/ssl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SslSslUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SslApi - functional programming interface
 * @export
 */
export const SslApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerSSLSettings> {
            const localVarFetchArgs = SslApiFetchParamCreator(configuration).sSLInspect(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body: SslSslUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SslApiFetchParamCreator(configuration).sSLUpdate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SslApi - factory interface
 * @export
 */
export const SslApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options?: any) {
            return SslApiFp(configuration).sSLInspect(options)(fetch, basePath);
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body: SslSslUpdatePayload, options?: any) {
            return SslApiFp(configuration).sSLUpdate(body, options)(fetch, basePath);
        },
    };
};

/**
 * SslApi - object-oriented interface
 * @export
 * @class SslApi
 * @extends {BaseAPI}
 */
export class SslApi extends BaseAPI {
    /**
     * Retrieve the ssl settings. **Access policy**: administrator
     * @summary Inspect the ssl settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    public sSLInspect(options?: any) {
        return SslApiFp(this.configuration).sSLInspect(options)(this.fetch, this.basePath);
    }

    /**
     * Update the ssl settings. **Access policy**: administrator
     * @summary Update the ssl settings
     * @param {SslSslUpdatePayload} body SSL Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    public sSLUpdate(body: SslSslUpdatePayload, options?: any) {
        return SslApiFp(this.configuration).sSLUpdate(body, options)(this.fetch, this.basePath);
    }

}

/**
 * StacksApi - fetch parameter creator
 * @export
 */
export const StacksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'swarmId' is not null or undefined
            if (swarmId === null || swarmId === undefined) {
                throw new RequiredError('swarmId','Required parameter swarmId was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'orphanedRunning' is not null or undefined
            if (orphanedRunning === null || orphanedRunning === undefined) {
                throw new RequiredError('orphanedRunning','Required parameter orphanedRunning was null or undefined when calling stackAssociate.');
            }
            const localVarPath = `/stacks/{id}/associate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (swarmId !== undefined) {
                localVarQueryParameter['swarmId'] = swarmId;
            }

            if (orphanedRunning !== undefined) {
                localVarQueryParameter['orphanedRunning'] = orphanedRunning;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type: number, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: any, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method','Required parameter method was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreate.');
            }
            const localVarPath = `/stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name: string, endpointId: number, env?: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling stackCreateDockerStandaloneFile.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneFile.');
            }
            const localVarPath = `/stacks/create/standalone/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (env !== undefined) {
                localVarFormParams.set('Env', env as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            console.log(localVarRequestOptions)
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneRepository.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateDockerStandaloneRepository.');
            }
            const localVarPath = `/stacks/create/standalone/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksComposeStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body: StacksComposeStackFromFileContentPayload, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateDockerStandaloneString.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneString.');
            }
            const localVarPath = `/stacks/create/standalone/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksComposeStackFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmFile.');
            }
            const localVarPath = `/stacks/create/swarm/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (name !== undefined) {
                localVarFormParams.set('Name', name as any);
            }

            if (swarmID !== undefined) {
                localVarFormParams.set('SwarmID', swarmID as any);
            }

            if (env !== undefined) {
                localVarFormParams.set('Env', env as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmRepository.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateDockerSwarmRepository.');
            }
            const localVarPath = `/stacks/create/swarm/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksSwarmStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body: StacksSwarmStackFromFileContentPayload, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateDockerSwarmString.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmString.');
            }
            const localVarPath = `/stacks/create/swarm/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksSwarmStackFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body: StacksKubernetesStringDeploymentPayload, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateKubernetesFile.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateKubernetesFile.');
            }
            const localVarPath = `/stacks/create/kubernetes/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksKubernetesStringDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body: StacksKubernetesGitDeploymentPayload, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateKubernetesGit.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateKubernetesGit.');
            }
            const localVarPath = `/stacks/create/kubernetes/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksKubernetesGitDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body: StacksKubernetesManifestURLDeploymentPayload, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackCreateKubernetesUrl.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackCreateKubernetesUrl.');
            }
            const localVarPath = `/stacks/create/kubernetes/url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksKubernetesManifestURLDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id: number, endpointId: number, external?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackDelete.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackDelete.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (external !== undefined) {
                localVarQueryParameter['external'] = external;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackFileInspect.');
            }
            const localVarPath = `/stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackGitRedeploy.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackGitRedeploy.');
            }
            const localVarPath = `/stacks/{id}/git/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksStackGitRedployPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackInspect.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters?: string, options: any = {}): FetchArgs {
            const localVarPath = `/stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackMigrate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackMigrate.');
            }
            const localVarPath = `/stacks/{id}/migrate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksStackMigratePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id: number, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackStart.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackStart.');
            }
            const localVarPath = `/stacks/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id: number, endpointId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackStop.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackStop.');
            }
            const localVarPath = `/stacks/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackUpdate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling stackUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackUpdate.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksUpdateSwarmStackPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling stackUpdateGit.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stackUpdateGit.');
            }
            const localVarPath = `/stacks/{id}/git`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StacksStackGitUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID','Required parameter webhookID was null or undefined when calling webhookInvoke.');
            }
            const localVarPath = `/stacks/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StacksApi - functional programming interface
 * @export
 */
export const StacksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type: number, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreate(type, method, endpointId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name: string, endpointId: number, env?: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerStandaloneRepository(endpointId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body: StacksComposeStackFromFileContentPayload, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerStandaloneString(body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerSwarmRepository(endpointId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body: StacksSwarmStackFromFileContentPayload, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateDockerSwarmString(body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body: StacksKubernetesStringDeploymentPayload, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateKubernetesFile(body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body: StacksKubernetesGitDeploymentPayload, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateKubernetesGit(body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body: StacksKubernetesManifestURLDeploymentPayload, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackCreateKubernetesUrl(body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id: number, endpointId: number, external?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackDelete(id, endpointId, external, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StacksStackFileResponse> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackFileInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackGitRedeploy(id, body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerStack>> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackList(filters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackMigrate(id, body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id: number, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackStart(id, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id: number, endpointId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackStop(id, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackUpdate(id, endpointId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerStack> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).stackUpdateGit(id, body, endpointId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StacksApiFetchParamCreator(configuration).webhookInvoke(webhookID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StacksApi - factory interface
 * @export
 */
export const StacksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: any) {
            return StacksApiFp(configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type: number, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: any, options?: any) {
            return StacksApiFp(configuration).stackCreate(type, method, endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name: string, endpointId: number, env?: string, file?: any, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerStandaloneRepository(endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body: StacksComposeStackFromFileContentPayload, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerStandaloneString(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: any, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerSwarmRepository(endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body: StacksSwarmStackFromFileContentPayload, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackCreateDockerSwarmString(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body: StacksKubernetesStringDeploymentPayload, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackCreateKubernetesFile(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body: StacksKubernetesGitDeploymentPayload, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackCreateKubernetesGit(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body: StacksKubernetesManifestURLDeploymentPayload, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackCreateKubernetesUrl(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id: number, endpointId: number, external?: boolean, options?: any) {
            return StacksApiFp(configuration).stackDelete(id, endpointId, external, options)(fetch, basePath);
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id: number, options?: any) {
            return StacksApiFp(configuration).stackFileInspect(id, options)(fetch, basePath);
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: any) {
            return StacksApiFp(configuration).stackGitRedeploy(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id: number, options?: any) {
            return StacksApiFp(configuration).stackInspect(id, options)(fetch, basePath);
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters?: string, options?: any) {
            return StacksApiFp(configuration).stackList(filters, options)(fetch, basePath);
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: any) {
            return StacksApiFp(configuration).stackMigrate(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id: number, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackStart(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id: number, endpointId: number, options?: any) {
            return StacksApiFp(configuration).stackStop(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: any) {
            return StacksApiFp(configuration).stackUpdate(id, endpointId, body, options)(fetch, basePath);
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: any) {
            return StacksApiFp(configuration).stackUpdateGit(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID: string, options?: any) {
            return StacksApiFp(configuration).webhookInvoke(webhookID, options)(fetch, basePath);
        },
    };
};

/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
export class StacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Associate an orphaned stack to a new environment(endpoint)
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {number} swarmId Swarm identifier
     * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: any) {
        return StacksApiFp(this.configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
     * @summary Deploy a new stack
     * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
     * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
     * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
     * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreate(type: number, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: any, options?: any) {
        return StacksApiFp(this.configuration).stackCreate(type, method, endpointId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a file
     * @param {string} name Name of the stack
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
     * @param {any} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneFile(name: string, endpointId: number, env?: string, file?: any, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneRepository(endpointId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a text
     * @param {StacksComposeStackFromFileContentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneString(body: StacksComposeStackFromFileContentPayload, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneString(body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a file
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} [name] Name of the stack
     * @param {string} [swarmID] Swarm cluster identifier.
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
     * @param {any} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: any, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a git repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmRepository(endpointId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a text
     * @param {StacksSwarmStackFromFileContentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmString(body: StacksSwarmStackFromFileContentPayload, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmString(body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a file
     * @param {StacksKubernetesStringDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesFile(body: StacksKubernetesStringDeploymentPayload, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackCreateKubernetesFile(body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a git repository
     * @param {StacksKubernetesGitDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesGit(body: StacksKubernetesGitDeploymentPayload, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackCreateKubernetesGit(body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a url
     * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesUrl(body: StacksKubernetesManifestURLDeploymentPayload, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackCreateKubernetesUrl(body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a stack. **Access policy**: restricted
     * @summary Remove a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackDelete(id: number, endpointId: number, external?: boolean, options?: any) {
        return StacksApiFp(this.configuration).stackDelete(id, endpointId, external, options)(this.fetch, this.basePath);
    }

    /**
     * Get Stack file content. **Access policy**: restricted
     * @summary Retrieve the content of the Stack file for the specified stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackFileInspect(id: number, options?: any) {
        return StacksApiFp(this.configuration).stackFileInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * Pull and redeploy a stack via Git **Access policy**: authenticated
     * @summary Redeploy a stack
     * @param {number} id Stack identifier
     * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy a stack
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: any) {
        return StacksApiFp(this.configuration).stackGitRedeploy(id, body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a stack. **Access policy**: restricted
     * @summary Inspect a stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackInspect(id: number, options?: any) {
        return StacksApiFp(this.configuration).stackInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. **Access policy**: authenticated
     * @summary List stacks
     * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackList(filters?: string, options?: any) {
        return StacksApiFp(this.configuration).stackList(filters, options)(this.fetch, this.basePath);
    }

    /**
     * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
     * @summary Migrate a stack to another environment(endpoint)
     * @param {number} id Stack identifier
     * @param {StacksStackMigratePayload} body Stack migration details
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: any) {
        return StacksApiFp(this.configuration).stackMigrate(id, body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Starts a stopped Stack. **Access policy**: authenticated
     * @summary Starts a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackStart(id: number, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackStart(id, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Stops a stopped Stack. **Access policy**: authenticated
     * @summary Stops a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackStop(id: number, endpointId: number, options?: any) {
        return StacksApiFp(this.configuration).stackStop(id, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a stack, only for file based stacks. **Access policy**: authenticated
     * @summary Update a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {StacksUpdateSwarmStackPayload} body Stack details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: any) {
        return StacksApiFp(this.configuration).stackUpdate(id, endpointId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
     * @summary Update a stack's Git configs
     * @param {number} id Stack identifier
     * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: any) {
        return StacksApiFp(this.configuration).stackUpdateGit(id, body, endpointId, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: public
     * @summary Webhook for triggering stack updates from git
     * @param {string} webhookID Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public webhookInvoke(webhookID: string, options?: any) {
        return StacksApiFp(this.configuration).webhookInvoke(webhookID, options)(this.fetch, this.basePath);
    }

}

/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options: any = {}): FetchArgs {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options: any = {}): FetchArgs {
            const localVarPath = `/status/nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options: any = {}): FetchArgs {
            const localVarPath = `/status/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemStatus> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).statusInspect(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemNodesCountResponse> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).statusNodesCount(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemVersionResponse> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).version(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options?: any) {
            return StatusApiFp(configuration).statusInspect(options)(fetch, basePath);
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options?: any) {
            return StatusApiFp(configuration).statusNodesCount(options)(fetch, basePath);
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any) {
            return StatusApiFp(configuration).version(options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusInspect(options?: any) {
        return StatusApiFp(this.configuration).statusInspect(options)(this.fetch, this.basePath);
    }

    /**
     * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusNodesCount(options?: any) {
        return StatusApiFp(this.configuration).statusNodesCount(options)(this.fetch, this.basePath);
    }

    /**
     * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public version(options?: any) {
        return StatusApiFp(this.configuration).version(options)(this.fetch, this.basePath);
    }

}

/**
 * SystemApi - fetch parameter creator
 * @export
 */
export const SystemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options: any = {}): FetchArgs {
            const localVarPath = `/system/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options: any = {}): FetchArgs {
            const localVarPath = `/system/nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options: any = {}): FetchArgs {
            const localVarPath = `/system/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options: any = {}): FetchArgs {
            const localVarPath = `/system/upgrade`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options: any = {}): FetchArgs {
            const localVarPath = `/system/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemSystemInfoResponse> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).systemInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemNodesCountResponse> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).systemNodesCount(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemStatus> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).systemStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemStatus> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).systemUpgrade(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SystemVersionResponse> {
            const localVarFetchArgs = SystemApiFetchParamCreator(configuration).systemVersion(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options?: any) {
            return SystemApiFp(configuration).systemInfo(options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options?: any) {
            return SystemApiFp(configuration).systemNodesCount(options)(fetch, basePath);
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options?: any) {
            return SystemApiFp(configuration).systemStatus(options)(fetch, basePath);
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options?: any) {
            return SystemApiFp(configuration).systemUpgrade(options)(fetch, basePath);
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options?: any) {
            return SystemApiFp(configuration).systemVersion(options)(fetch, basePath);
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Retrieve system info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemInfo(options?: any) {
        return SystemApiFp(this.configuration).systemInfo(options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemNodesCount(options?: any) {
        return SystemApiFp(this.configuration).systemNodesCount(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemStatus(options?: any) {
        return SystemApiFp(this.configuration).systemStatus(options)(this.fetch, this.basePath);
    }

    /**
     * Upgrade Portainer to BE **Access policy**: administrator
     * @summary Upgrade Portainer to BE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUpgrade(options?: any) {
        return SystemApiFp(this.configuration).systemUpgrade(options)(this.fetch, this.basePath);
    }

    /**
     * Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemVersion(options?: any) {
        return SystemApiFp(this.configuration).systemVersion(options)(this.fetch, this.basePath);
    }

}

/**
 * TagsApi - fetch parameter creator
 * @export
 */
export const TagsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body: TagsTagCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tagCreate.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagsTagCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling tagDelete.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options: any = {}): FetchArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body: TagsTagCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTag> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerTag>> {
            const localVarFetchArgs = TagsApiFetchParamCreator(configuration).tagList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body: TagsTagCreatePayload, options?: any) {
            return TagsApiFp(configuration).tagCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id: number, options?: any) {
            return TagsApiFp(configuration).tagDelete(id, options)(fetch, basePath);
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options?: any) {
            return TagsApiFp(configuration).tagList(options)(fetch, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Create a new tag. **Access policy**: administrator
     * @summary Create a new tag
     * @param {TagsTagCreatePayload} body Tag details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagCreate(body: TagsTagCreatePayload, options?: any) {
        return TagsApiFp(this.configuration).tagCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a tag. **Access policy**: administrator
     * @summary Remove a tag
     * @param {number} id Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagDelete(id: number, options?: any) {
        return TagsApiFp(this.configuration).tagDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * List tags. **Access policy**: authenticated
     * @summary List tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagList(options?: any) {
        return TagsApiFp(this.configuration).tagList(options)(this.fetch, this.basePath);
    }

}

/**
 * TeamMembershipsApi - fetch parameter creator
 * @export
 */
export const TeamMembershipsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamMembershipCreate.');
            }
            const localVarPath = `/team_memberships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeammembershipsTeamMembershipCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamMembershipDelete.');
            }
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options: any = {}): FetchArgs {
            const localVarPath = `/team_memberships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamMembershipUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamMembershipUpdate.');
            }
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeammembershipsTeamMembershipUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamMemberships.');
            }
            const localVarPath = `/teams/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamMembershipsApi - functional programming interface
 * @export
 */
export const TeamMembershipsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeamMembership> {
            const localVarFetchArgs = TeamMembershipsApiFetchParamCreator(configuration).teamMembershipCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamMembershipsApiFetchParamCreator(configuration).teamMembershipDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerTeamMembership>> {
            const localVarFetchArgs = TeamMembershipsApiFetchParamCreator(configuration).teamMembershipList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeamMembership> {
            const localVarFetchArgs = TeamMembershipsApiFetchParamCreator(configuration).teamMembershipUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerTeamMembership>> {
            const localVarFetchArgs = TeamMembershipsApiFetchParamCreator(configuration).teamMemberships(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamMembershipsApi - factory interface
 * @export
 */
export const TeamMembershipsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: any) {
            return TeamMembershipsApiFp(configuration).teamMembershipCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id: number, options?: any) {
            return TeamMembershipsApiFp(configuration).teamMembershipDelete(id, options)(fetch, basePath);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options?: any) {
            return TeamMembershipsApiFp(configuration).teamMembershipList(options)(fetch, basePath);
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: any) {
            return TeamMembershipsApiFp(configuration).teamMembershipUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id: number, options?: any) {
            return TeamMembershipsApiFp(configuration).teamMemberships(id, options)(fetch, basePath);
        },
    };
};

/**
 * TeamMembershipsApi - object-oriented interface
 * @export
 * @class TeamMembershipsApi
 * @extends {BaseAPI}
 */
export class TeamMembershipsApi extends BaseAPI {
    /**
     * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Create a new team membership
     * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: any) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Remove a team membership
     * @param {number} id TeamMembership identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipDelete(id: number, options?: any) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
     * @summary List team memberships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipList(options?: any) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipList(options)(this.fetch, this.basePath);
    }

    /**
     * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
     * @summary Update a team membership
     * @param {number} id Team membership identifier
     * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: any) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
     * @summary List team memberships
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMemberships(id: number, options?: any) {
        return TeamMembershipsApiFp(this.configuration).teamMemberships(id, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamsApi - fetch parameter creator
 * @export
 */
export const TeamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body: TeamsTeamCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamCreate.');
            }
            const localVarPath = `/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamsTeamCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamDelete.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamInspect.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams?: boolean, environmentId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (onlyLedTeams !== undefined) {
                localVarQueryParameter['onlyLedTeams'] = onlyLedTeams;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id: number, body: TeamsTeamUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling teamUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling teamUpdate.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamsTeamUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body: TeamsTeamCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeam> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeam> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams?: boolean, environmentId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerTeam>> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamList(onlyLedTeams, environmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeam> {
            const localVarFetchArgs = TeamsApiFetchParamCreator(configuration).teamUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body: TeamsTeamCreatePayload, options?: any) {
            return TeamsApiFp(configuration).teamCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id: number, options?: any) {
            return TeamsApiFp(configuration).teamDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id: number, options?: any) {
            return TeamsApiFp(configuration).teamInspect(id, options)(fetch, basePath);
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams?: boolean, environmentId?: number, options?: any) {
            return TeamsApiFp(configuration).teamList(onlyLedTeams, environmentId, options)(fetch, basePath);
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: any) {
            return TeamsApiFp(configuration).teamUpdate(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Create a new team. **Access policy**: administrator
     * @summary Create a new team
     * @param {TeamsTeamCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamCreate(body: TeamsTeamCreatePayload, options?: any) {
        return TeamsApiFp(this.configuration).teamCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a team. **Access policy**: administrator
     * @summary Remove a team
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamDelete(id: number, options?: any) {
        return TeamsApiFp(this.configuration).teamDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
     * @summary Inspect a team
     * @param {number} id Team identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamInspect(id: number, options?: any) {
        return TeamsApiFp(this.configuration).teamInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
     * @summary List teams
     * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamList(onlyLedTeams?: boolean, environmentId?: number, options?: any) {
        return TeamsApiFp(this.configuration).teamList(onlyLedTeams, environmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a team. **Access policy**: administrator
     * @summary Update a team
     * @param {number} id Team identifier
     * @param {TeamsTeamUpdatePayload} body Team details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: any) {
        return TeamsApiFp(this.configuration).teamUpdate(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(body: TemplatesFilePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling templateFile.');
            }
            const localVarPath = `/templates/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesFilePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options: any = {}): FetchArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(body: TemplatesFilePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplatesFileResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).templateFile(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplatesListResponse> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).templateList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(body: TemplatesFilePayload, options?: any) {
            return TemplatesApiFp(configuration).templateFile(body, options)(fetch, basePath);
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options?: any) {
            return TemplatesApiFp(configuration).templateList(options)(fetch, basePath);
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Get a template's file **Access policy**: authenticated
     * @summary Get a template's file
     * @param {TemplatesFilePayload} body File details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateFile(body: TemplatesFilePayload, options?: any) {
        return TemplatesApiFp(this.configuration).templateFile(body, options)(this.fetch, this.basePath);
    }

    /**
     * List available templates. **Access policy**: authenticated
     * @summary List available templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateList(options?: any) {
        return TemplatesApiFp(this.configuration).templateList(options)(this.fetch, this.basePath);
    }

}

/**
 * UploadApi - fetch parameter creator
 * @export
 */
export const UploadApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: any, options: any = {}): FetchArgs {
            // verify required parameter 'certificate' is not null or undefined
            if (certificate === null || certificate === undefined) {
                throw new RequiredError('certificate','Required parameter certificate was null or undefined when calling uploadTLS.');
            }
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder','Required parameter folder was null or undefined when calling uploadTLS.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadTLS.');
            }
            const localVarPath = `/upload/tls/{certificate}`
                .replace(`{${"certificate"}}`, encodeURIComponent(String(certificate)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (folder !== undefined) {
                localVarFormParams.set('folder', folder as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UploadApiFetchParamCreator(configuration).uploadTLS(certificate, folder, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: any, options?: any) {
            return UploadApiFp(configuration).uploadTLS(certificate, folder, file, options)(fetch, basePath);
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload TLS files
     * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
     * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
     * @param {any} file The file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: any, options?: any) {
        return UploadApiFp(this.configuration).uploadTLS(certificate, folder, file, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options: any = {}): FetchArgs {
            const localVarPath = `/users/admin/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body: UsersAdminInitPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userAdminInit.');
            }
            const localVarPath = `/users/admin/init`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersAdminInitPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body: UsersUserCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userCreate.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersUserCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userDelete.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userGenerateAPIKey.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userGenerateAPIKey.');
            }
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersUserAccessTokenCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userGetAPIKeys.');
            }
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userInspect.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userMembershipsInspect.');
            }
            const localVarPath = `/users/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id: number, keyID: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userRemoveAPIKey.');
            }
            // verify required parameter 'keyID' is not null or undefined
            if (keyID === null || keyID === undefined) {
                throw new RequiredError('keyID','Required parameter keyID was null or undefined when calling userRemoveAPIKey.');
            }
            const localVarPath = `/users/{id}/tokens/{keyID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"keyID"}}`, encodeURIComponent(String(keyID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id: number, body: UsersUserUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userUpdate.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersUserUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userUpdatePassword.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userUpdatePassword.');
            }
            const localVarPath = `/users/{id}/passwd`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersUserUpdatePasswordPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userAdminCheck(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body: UsersAdminInitPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userAdminInit(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body: UsersUserCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userCreate(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersAccessTokenResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userGenerateAPIKey(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerAPIKey>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userGetAPIKeys(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerUser>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userList(environmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerTeamMembership> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userMembershipsInspect(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id: number, keyID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userRemoveAPIKey(id, keyID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id: number, body: UsersUserUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userUpdate(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).userUpdatePassword(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options?: any) {
            return UsersApiFp(configuration).userAdminCheck(options)(fetch, basePath);
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body: UsersAdminInitPayload, options?: any) {
            return UsersApiFp(configuration).userAdminInit(body, options)(fetch, basePath);
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body: UsersUserCreatePayload, options?: any) {
            return UsersApiFp(configuration).userCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id: number, options?: any) {
            return UsersApiFp(configuration).userDelete(id, options)(fetch, basePath);
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: any) {
            return UsersApiFp(configuration).userGenerateAPIKey(id, body, options)(fetch, basePath);
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id: number, options?: any) {
            return UsersApiFp(configuration).userGetAPIKeys(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id: number, options?: any) {
            return UsersApiFp(configuration).userInspect(id, options)(fetch, basePath);
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId?: number, options?: any) {
            return UsersApiFp(configuration).userList(environmentId, options)(fetch, basePath);
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id: number, options?: any) {
            return UsersApiFp(configuration).userMembershipsInspect(id, options)(fetch, basePath);
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id: number, keyID: number, options?: any) {
            return UsersApiFp(configuration).userRemoveAPIKey(id, keyID, options)(fetch, basePath);
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id: number, body: UsersUserUpdatePayload, options?: any) {
            return UsersApiFp(configuration).userUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: any) {
            return UsersApiFp(configuration).userUpdatePassword(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Check if an administrator account exists in the database. **Access policy**: public
     * @summary Check administrator account existence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userAdminCheck(options?: any) {
        return UsersApiFp(this.configuration).userAdminCheck(options)(this.fetch, this.basePath);
    }

    /**
     * Initialize the 'admin' user account. **Access policy**: public
     * @summary Initialize administrator account
     * @param {UsersAdminInitPayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userAdminInit(body: UsersAdminInitPayload, options?: any) {
        return UsersApiFp(this.configuration).userAdminInit(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
     * @summary Create a new user
     * @param {UsersUserCreatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userCreate(body: UsersUserCreatePayload, options?: any) {
        return UsersApiFp(this.configuration).userCreate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a user. **Access policy**: administrator
     * @summary Remove a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDelete(id: number, options?: any) {
        return UsersApiFp(this.configuration).userDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Generates an API key for a user. Only the calling user can generate a token for themselves. **Access policy**: restricted
     * @summary Generate an API key for a user
     * @param {number} id User identifier
     * @param {UsersUserAccessTokenCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: any) {
        return UsersApiFp(this.configuration).userGenerateAPIKey(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
     * @summary Get all API keys for a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGetAPIKeys(id: number, options?: any) {
        return UsersApiFp(this.configuration).userGetAPIKeys(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     * @summary Inspect a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userInspect(id: number, options?: any) {
        return UsersApiFp(this.configuration).userInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
     * @summary List users
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userList(environmentId?: number, options?: any) {
        return UsersApiFp(this.configuration).userList(environmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Inspect a user memberships. **Access policy**: restricted
     * @summary Inspect a user memberships
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userMembershipsInspect(id: number, options?: any) {
        return UsersApiFp(this.configuration).userMembershipsInspect(id, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
     * @summary Remove an api-key associated to a user
     * @param {number} id User identifier
     * @param {number} keyID Api Key identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRemoveAPIKey(id: number, keyID: number, options?: any) {
        return UsersApiFp(this.configuration).userRemoveAPIKey(id, keyID, options)(this.fetch, this.basePath);
    }

    /**
     * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
     * @summary Update a user
     * @param {number} id User identifier
     * @param {UsersUserUpdatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdate(id: number, body: UsersUserUpdatePayload, options?: any) {
        return UsersApiFp(this.configuration).userUpdate(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update password for the specified user. **Access policy**: authenticated
     * @summary Update password for a user
     * @param {number} id identifier
     * @param {UsersUserUpdatePasswordPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: any) {
        return UsersApiFp(this.configuration).userUpdatePassword(id, body, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {number} [endpointID] 
         * @param {string} [resourceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(endpointID?: number, resourceID?: string, options: any = {}): FetchArgs {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointID !== undefined) {
                localVarQueryParameter['EndpointID'] = endpointID;
            }

            if (resourceID !== undefined) {
                localVarQueryParameter['ResourceID'] = resourceID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling webhooksIdDelete.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling webhooksIdPost.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling webhooksIdPut.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling webhooksIdPut.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhooksWebhookUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body: WebhooksWebhookCreatePayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling webhooksPost.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhooksWebhookCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {number} [endpointID] 
         * @param {string} [resourceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(endpointID?: number, resourceID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PortainerWebhook>> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGet(endpointID, resourceID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksIdPost(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerWebhook> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksIdPut(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body: WebhooksWebhookCreatePayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PortainerWebhook> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {number} [endpointID] 
         * @param {string} [resourceID] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(endpointID?: number, resourceID?: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksGet(endpointID, resourceID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id: number, options?: any) {
            return WebhooksApiFp(configuration).webhooksIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksIdPost(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: any) {
            return WebhooksApiFp(configuration).webhooksIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body: WebhooksWebhookCreatePayload, options?: any) {
            return WebhooksApiFp(configuration).webhooksPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary List webhooks
     * @param {number} [endpointID] 
     * @param {string} [resourceID] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGet(endpointID?: number, resourceID?: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGet(endpointID, resourceID, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Delete a webhook
     * @param {number} id Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdDelete(id: number, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Acts on a passed in token UUID to restart the docker service **Access policy**: public
     * @summary Execute a webhook
     * @param {string} id Webhook token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdPost(id: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksIdPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Update a webhook
     * @param {number} id Webhook id
     * @param {WebhooksWebhookUpdatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksIdPut(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * **Access policy**: authenticated
     * @summary Create a webhook
     * @param {WebhooksWebhookCreatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksPost(body: WebhooksWebhookCreatePayload, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksPost(body, options)(this.fetch, this.basePath);
    }

}

/**
 * WebsocketApi - fetch parameter creator
 * @export
 */
export const WebsocketApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId: number, token: string, nodeName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling websocketAttachGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling websocketAttachGet.');
            }
            const localVarPath = `/websocket/attach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId: number, token: string, nodeName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling websocketExecGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling websocketExecGet.');
            }
            const localVarPath = `/websocket/exec`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId: number, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling websocketKubernetesShellGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling websocketKubernetesShellGet.');
            }
            const localVarPath = `/websocket/kubernetes-shell`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId','Required parameter endpointId was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'podName' is not null or undefined
            if (podName === null || podName === undefined) {
                throw new RequiredError('podName','Required parameter podName was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'containerName' is not null or undefined
            if (containerName === null || containerName === undefined) {
                throw new RequiredError('containerName','Required parameter containerName was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling websocketPodGet.');
            }
            const localVarPath = `/websocket/pod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (podName !== undefined) {
                localVarQueryParameter['podName'] = podName;
            }

            if (containerName !== undefined) {
                localVarQueryParameter['containerName'] = containerName;
            }

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebsocketApiFetchParamCreator(configuration).websocketAttachGet(endpointId, token, nodeName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebsocketApiFetchParamCreator(configuration).websocketExecGet(endpointId, token, nodeName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId: number, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebsocketApiFetchParamCreator(configuration).websocketKubernetesShellGet(endpointId, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebsocketApiFetchParamCreator(configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: any) {
            return WebsocketApiFp(configuration).websocketAttachGet(endpointId, token, nodeName, options)(fetch, basePath);
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: any) {
            return WebsocketApiFp(configuration).websocketExecGet(endpointId, token, nodeName, options)(fetch, basePath);
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId: number, token: string, options?: any) {
            return WebsocketApiFp(configuration).websocketKubernetesShellGet(endpointId, token, options)(fetch, basePath);
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: any) {
            return WebsocketApiFp(configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options)(fetch, basePath);
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
     * @summary Attach a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: any) {
        return WebsocketApiFp(this.configuration).websocketAttachGet(endpointId, token, nodeName, options)(this.fetch, this.basePath);
    }

    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
     * @summary Execute a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: any) {
        return WebsocketApiFp(this.configuration).websocketExecGet(endpointId, token, nodeName, options)(this.fetch, this.basePath);
    }

    /**
     * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
     * @summary Execute a websocket on kubectl shell pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketKubernetesShellGet(endpointId: number, token: string, options?: any) {
        return WebsocketApiFp(this.configuration).websocketKubernetesShellGet(endpointId, token, options)(this.fetch, this.basePath);
    }

    /**
     * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
     * @summary Execute a websocket on pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} namespace namespace where the container is located
     * @param {string} podName name of the pod containing the container
     * @param {string} containerName name of the container
     * @param {string} command command to execute in the container
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: any) {
        return WebsocketApiFp(this.configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options)(this.fetch, this.basePath);
    }

}

